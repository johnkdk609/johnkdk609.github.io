---
layout: post
title: 좋은 객체 지향 프로그래밍이란?
description: 스프링 핵심 원리 - 기본편
categories: Spring-SpringBoot
date: 2023-10-14 13:18:00 +0900
---
좋은 객체 지향 프로그래밍이 무엇인지 알아보겠다.

## 객체 지향 특징

* 추상화
* 캡슐화
* 상속
* <b>다형성</b>

객체 지향은 위의 네 가지 특성을 가지고 있다. (자바 초급 수준이라고 할 수 있다.)

객체 지향 프로그래밍에 대한 위키의 정리는 아래와 같다.

* 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 <b>"객체"들의 모임</b>으로 파악하고자 하는 것이다. 각각의 <b>객체는 메시지를 주고받고</b>, 데이터를 처리할 수 있다. (<b>협력</b>)
* 객체 지향 프로그래밍은 프로그램을 <b>유연하고 변경이 용이</b>하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

여기서 핵심 키워드는 '객체들의 모임', '메시지를 주고받고', '유연하고 변경이 용이'이다.

<br>

'<b>유연하고 변경이 용이</b>'하다는 뜻이 뭘까?

* 레고 블럭을 조립하듯이
* 키보드, 마우스 갈아 끼우듯이
* 컴퓨터 부품 갈아 끼우듯이

컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법이 '유연하고 변경이 용이'한 객체 지향의 가장 큰 방법이다. 궁극의 유연함과 궁극의 변경이 용이한 방법, 즉 <b><u>다형성(Polymorphism)</u><b>이다.


## 다형성 (Polymorphism)

다형성을 먼저 실세계로 비유를 들어 보겠다. 프로그래밍 언어를 실세계와 비유했을 때 1:1로 깔끔하게 매칭이 되지는 않는다. 하지만, 실세계의 비유로 이해하기에는 좋다.

이 세상을 <b>역할</b>과 그 역할을 직접 행하는 <b>구현</b>으로 구분해보겠다.

* <b>역할: 인터페이스</b>
* <b>구현: 인터페이스를 구현한 객체</b>

<br>

먼저 운전자 - 자동차 예제이다.

<img width="1147" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/458700ae-188f-4241-9d3b-bf5a758142c3">

운전자라는 역할이 있고, 자동차라는 역할이 있다. 자동차라는 역할을 K3, 아반떼, 테슬라 모델3 즉 3개의 자동차들이 구현했다.

운전자는 K3를 타다가 아반떼로 차를 바꿔도 운전할 수 있다. 왜냐하면 자동차라는 역할에 대한 구현만 바뀌었기 때문이다. <b>자동차가 바뀌어도 운전자에게 영향을 주지 않는다.</b> 내가 테슬라 모델3를 산다고 해서 다른 운전면허를 따야 하는 것은 아니다. (물론 내가 비행기 정도 타면 완전히 바뀌는 것이니 다른 운전 면허를 따야 한다.) 왜 그런 것이냐면 자동차 역할의 인터페이스에 따라서 자동차를 구현했기 때문이다. 운전자는 자동차 역할(인터페이스)에 대해서만 의존하고 있으면 된다. 

자동차라는 <b>역할을 만들고 구현을 분리한 것은 운전자를 위해서 그렇게 한 것</b>이다. 운전자는 클라이언트이다. 클라이언트는 자동차의 내부 구조는 몰라도 된다. <b>구현체들이 내부적으로 바뀌더라도 어쨌든 자동차 역할만 그대로 맞춰서 하고 있으면 클라이언트에게 영향을 주지 않는다.</b> 

이렇게 되면 새로운 자동차가 계속 나올 수 있고, <u>자동차 세상을 무한히 확장시킬 수 있는 것</u>이다. 세상을 바꾸지 않고 새로운 자동차를 출시할 수 있는 것이다. 이것을 조금 더 디테일하게 얘기하면, <b>클라이언트에게 영향을 주지 않고 새로운 기능을 제공할 수 있다는 것</b>이다. 이게 가능한 이유는 역할과 구현으로 세상을 구분했기 때문이다. 정말 중요한 부분은 내가 자동차 역할을 여러 개 구현할 수 있는 것이 아니고, 새로운 자동차가 나와도 클라이언트는 새로운 것을 안 배워도 되는 것이다. 즉, 클라이언트를 바꿀 필요가 없는 것이다.

<br>

이번에는 공연 무대 예제이다.

<img width="1097" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/c5812c83-3888-45f4-9125-8b7d44af3b52">

예를 들어 로미오와 줄리엣 공연이 있다고 할 때, 로미오라는 역할이 있고 줄리엣이라는 역할이 있다. 로미오라는 역할을 장동건이 할 수도 있고 원빈이 할 수도 있다. 줄리엣이라는 역할을 김태희가 할 수도 있고 송혜교가 할 수도 있다.

로미오와 줄리엣 공연을 할 때에는 배우는 대체가 가능해야 한다. 만약 다 몸이 아프면 무명 배우로라도 대체가 가능해야 한다. 공연은 진행돼야 하기 때문이다.

로미오와 줄리엣 공연에서도 역할과 구현의 분리가 이뤄진 것을 볼 수 있다. 그러면 대체 가능성이 생기고, 이게 바로 '유연하고 변경이 용이'한 것이다. 내부 구조를 몰라도 된다. 로미오 역할을 하는 사람은 줄리엣 역할을 김태희가 하든 송혜교가 하든, 상관이 없다. 충실히 대본에 따라서 하면 되는 것이다.

로미오가 클라이언트, 줄리엣이 서버라고 가정해보자. 줄리엣의 구현이 바뀐다고 해서 로미오의 역할에는 영향을 주지 않는다. 다른 대상으로 대체가 가능하다.


### 역할과 구현을 분리

결론적으로 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며, 변경도 편리해진다.

장점
* <b>클라이언트</b>는 대상의 역할(인터페이스)만 알면 된다.
* <b>클라이언트</b>는 구현 대상의 <b>내부 구조를 몰라도 된다.</b>
* <b>클라이언트</b>는 구현 대상의 <b>내부 구조가 변경되어도</b> 영향을 받지 않는다.
* <b>클라이언트</b>는 구현 <b>대상 자체를 변경해도</b> 영향을 받지 않는다.

<br>

자바 언어도 결과적으로 이러한 개념을 차용한 것이다.

* 자바 언어는 <b>다형성</b>을 활용한다.
    * 역할 = 인터페이스
    * 구현 = 인터페이스를 구현한 클래스, 구현 객체
* 객체를 설계할 때 역할과 구현을 명확히 분리
* 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

핵심은 구현보다 인터페이스가 먼저라는 것이다. 역할이 더 중요하다.

<br>

### 객체의 협력이라는 관계부터 생각

혼자 있는 객체는 없다.

우리가 다형성을 공부할 때 오해하는 것 중 하나가, 다형성이라는 것이 부모가 있고 그것을 구현한 것이고.. 공부할 때에는 클라이언트가 없다는 것이다. 중요한 것은 사실 클라이언트가 중요하다. 클라이언트는 요청하는 사람이고, 서버는 그 요청을 받아서 응답하는 사람이라고 보면 된다. 그래서 수많은 객체 클라이언트와 수많은 객체 서버가 서로 요청하고 응답하면서 협력 관계를 가진다.

* 클라이언트: <b>요청</b>, 서버: <b>응답</b>

참고로 이것을 단순한 객체끼리의 요청과 응답이라고 볼 수도 있고, 개념이 커지면 여러 서버끼리, 시스템끼리 요청을 주고받을 수 있다.

<br>

<img width="944" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/fed045c4-388d-4aae-b87c-b86aa3c79b5e">

위 그림 중 위쪽은 클라이언트가 서버에 요청하는 그림이고, 밑에 그림을 보면 클라이언트는 동시에 서버가 될 수도 있다. 클라이언트가 서버에게 요청을 하고, 서버가 또 클라이언트가 되어서 다른 서버들한테 요청을 할 수 있는 것이다. (물론 여기서 응답이라는 개념이 데이터를 넣어서 리턴값이 꼭 없어도 된다. 내부적으로 무언가를 print하는 등.. 어쨌든 클라이언트가 요청하는 행위를 하는 것이 응답이라고 보면 된다.)

### 자바 언어의 다형성

자바 언어는 다형성을 어떻게 구현하는가? 오버라이딩을 떠올려보자. 오버라이딩은 자바의 기본 문법이고, 결과적으로 오버라이딩 된 메서드가 실행된다.

<img width="866" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/f1252749-a009-4d92-a209-32242b1df592">

위 그림을 보면 MemberService가 save() 메서드를 호출해서 인터페이스 MemberRepository에서 save()를 호출하면, 실제 어떤 save()가 호출되냐면, 예를 들어 MemoryMemberRepository가 현재 들어가 있으면 MemoryMemberRepository에 있는 save()가 호출되고, JdbcMemberRepository 객체가 들어가 있으면 JdbcMemberRepository의 save()가 호출되는 것이 오버라이딩이다.

다형성을 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있는 것이 자바 언어가 가진 다형성의 장점이다. 물론 클래스 상속 관계도 다형성, 오버라이딩이 적용이 된다.

<img width="649" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/771f886d-3c78-42b7-a72b-9649886a2682">

그래서 위 그림과 같이 클라이언트가 MemberService라 보고, 이 클라이언트는 MemberRepository를 의존한다. (의존한다는 것은 '쟤를 알고 있다'는 것이다.) 그런데 MemberRepository인터페이스를 구현한 MemoryMemberRepository와 JdbcMemberRepository를 할당할 수 있다.

<img width="1000" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/7ed1ba89-2aa9-46df-994f-da72f67cd8c7">

예를 들어, 위 코드처럼 MemberService가 MemberRepository인터페이스를 선언해놓고 그것에 대해 값을 MemoryMemberRepository를 대입할 수 있고, 그것을 JdbcMemberRepository로 넣을 수도 있다. 다형성이기 때문에 가능한 것이다.

<br>

한편, MemberRepository인터페이스가 부모와 전혀 관계가 없는 애는 할당할 수 없다.

<img width="625" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/52f63cde-9267-436d-9a1f-b246804c43df">

<br>

결론적으로, 파란색인 클라이언트에 MemberRepository인터페이스가 있는데 여기에 빨간색인 MemoryMemberRepository를 넣으면 파란색 클라이언트가 빨간색 서버를 바라보는 그림이 되는 것이고, 초록색인 JdbcMemberRepository를 넣으면 파란색 클라이언트가 초록색 서버를 보게 되고 save()를 호출하면 초록색 서버에 있는 save()가 호출된다.

<img width="452" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/001d83f5-d78c-400f-b7e1-d9532ff49fce">

### 다형성의 본질

다형성의 본질은 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다는 것이다. 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야 한다.

<b><u>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있는 것이 다형성의 본질</u></b>이다.

<br>

## 역할과 구현을 분리 정리 & 한계점

* <b>정리</b>
    * <b>실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음</b>
    * 유연하고 변경이 용이
    * 확장 가능한 설계
    * 클라이언트에 영향을 주지 않는 변경 가능
    * <b>인터페이스를 안정적으로 잘 설계하는 것이 중요</b>

* <b>한계점</b>
    * <b>역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 필요하다.</b>
    * 자동차를 비행기로 변경해야 한다면?
    * 대본 자체가 변경되었다면?
    * USB 인터페이스가 변경된다면?
    * <b>인터페이스를 안정적으로 잘 설계하는 것이 중요</b>

## 스프링과 객체 지향

객체 지향의 개념들 중에서 다형성이 가장 중요하다. 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.

스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있돌고 지원한다. 사실 스프링 컨테이너가 제공하는 것은 이 다형성을 편리하게 사용할 수 있도록 지원하는 기능이고, 어쩌면 그게 전부일 수 있다. 그렇기 때문에 스프링을 사용하면 마치 레고 블럭을 조립하듯이, 공연 무대의 배우를 선택하듯이 구현을 편리하게 변경할 수 있는 것이다.

<br>

스프링과 객체 지향 설계에 대해 제대로 이해하려면 다형성 외에 한 가지를 더 알아야 한다. 그것은 바로 좋은 객체 지향 설계의 5가지 원칙(SOLID)이다. 다형성과 SOLID를 합쳐야 스프링에 대해 제대로 설명할 수 있는 것이다.