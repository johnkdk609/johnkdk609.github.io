---
layout: post
title: 파이썬 배열 회전, 전치
categories: Python
date: 2024-09-06 20:00:00 +0900
---
파이썬으로 2차원 배열 다루다 보면 '배열 회전'을 하는 경우가 빈번하게 나온다.

다음과 같은 2차원 배열이 있다고 해보자.

```python
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

이 배열을 시계방향으로 90도 돌리면 다음과 같이 된다.

```
[7, 4, 1]
[8, 5, 2]
[9, 6, 3]
```

<br>

시계방향 90도 회전, 180도 회전, 270도 회전, 그리고 반시계방향 90도 회전, 180도 회전, 270도 회전을 다 할 수 있어야 한다. 그런데 반시계방향 90도 회전은 곧 시계방향 270도 회전이니 한쪽 방향을 정확히 알고 있으면 문제 없다.

<br>

## 배열 인덱스로 회전 구현

행, 열 좌표를 통해 시계방향 90도, 180도, 270도 회전을 해보겠다.

### 시계방향 90도 회전

```python
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

rotated90 = [[0 for _ in range(len(arr[0]))] for _ in range(len(arr))]
for r in range(len(arr)):
    for c in range(len(arr[r])):
        rotated90[r][c] = arr[len(arr) - (c + 1)][r]

print(*rotated90, sep='\n')

# [7, 4, 1]
# [8, 5, 2]
# [9, 6, 3]
```

행, 열 순회를 돌면서 값이 변경되기 때문에, 원본 배열이 아닌 새로 생성한 배열에서 작업을 진행해야 연쇄 작용이 발생하지 않는다.

<br>

### 시계방향 180도 회전

```python
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

rotated180 = [[0 for _ in range(len(arr[0]))] for _ in range(len(arr))]
for r in range(len(arr)):
    for c in range(len(arr[r])):
        rotated180[r][c] = arr[len(arr) - (r + 1)][len(arr) - (c + 1)]

print(*rotated180, sep='\n')

# [9, 8, 7]
# [6, 5, 4]
# [3, 2, 1]
```

<br>

### 시계방향 270도 회전

```python
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

rotated270 = [[0 for _ in range(len(arr[0]))] for _ in range(len(arr))]
for r in range(len(arr)):
    for c in range(len(arr[r])):
        rotated270[r][c] = arr[c][len(arr) - (r + 1)]

print(*rotated270, sep='\n')

# [3, 6, 9]
# [2, 5, 8]
# [1, 4, 7]
```

<br>

## 간단하게 시계방향 90도 회전 하는 방법

위와 같이 직접 인덱스를 활용해 배열 회전을 수행할 수도 있으나, 파이썬의 zip 함수와 언패킹 연산자(*) 사용하면 코드 한 줄에 시계방향 90도 회전을 구현할 수 있다.

```python
arr = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

rotated90 = [list(row[::-1]) for row in zip(*arr)]

print(*rotated90, sep='\n')

# [9, 5, 1]
# [10, 6, 2]
# [11, 7, 3]
# [12, 8, 4]
```

위 예시에서도 알 수 있겠지만, 이렇게 간결하게 배열 회전을 수행하면 배열의 가로, 세로 길이가 다르더라도 문제 없이 수행된다. 만약 내가 가로, 세로의 길이가 다른 배열을 직접 회전한 결과를 담을 배열을 만들고, 인덱스로 접근하려면 고려해야 할 것이 많아진다. 새로 생성한 배열의 가로 길이를 원본 배열의 세로 길이로, 세로 길이를 원본 배열의 가로 길이로 지정해줘야 하는 것이다. 하지만 위 방식을 사용하면 그런 것을 고민할 필요가 없다.

<br>

반복문을 활용해 회전을 원하는 만큼 추가로 수행할 수 있다. 한 번 수행하면 시계방향 90도 회전, 두 번 수행하면 시계방향 180도 회전, 세 번 수행하면 시계방향 270도 회전인 것이다.

```python
arr = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

for i in range(2):
    arr = [list(row[::-1]) for row in zip(*arr)]    # 반복해서 회전을 시킬 것이기 때문에, 원본 배열과 같은 이름으로 설정해야 한다.

print(*arr, sep='\n')

# [12, 11, 10, 9]
# [8, 7, 6, 5]
# [4, 3, 2, 1]
```

<br>

## 2차원 배열 전치

2차원 배열을 회전하는 것 외에도, 전치(transpose)할 수 있다. 이때 전치란, 어떤 2차원 배열에 대해 오른쪽 아래 방향 대각선(\\)을 기준으로 배열의 값들을 뒤집는 것이다.

전치를 할 때에도 행 ~ 열 순회를 돌며 인덱스로 접근하는 방식으로 수행할 수 있다. 하지만 위에서 시계방향 회전을 한 줄의 코드로 간결하게 했듯이, zip 함수와 unpacking 연산자(*)를 사용하여 행과 열을 교환할 수 있다.

코드는 다음과 같다.

```python
arr = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

# 전치 함수
def transpose(arr):
    return [list(row) for row in zip(*arr)]

# 전치된 배열 출력
transposed_arr = transpose(arr)
print(*transposed_arr, sep='\n')

# [1, 5, 9]
# [2, 6, 10]
# [3, 7, 11]
# [4, 8, 12]
```