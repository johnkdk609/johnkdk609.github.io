---
layout: post
title: 1차원 배열 (Array)
categories: Java
date: 2024-01-16 21:43:00 +0900
---
자바 배열(Array)의 특성으로는 다음과 같은 것들이 있다.

- 같은 종류의 데이터를 저장하기 위한 데이터 구조
- 크기가 고정되어 있음. 한 번 생성된 배열은 크기를 바꿀 수 없다.
- 배열을 객체로 취급한다. 참조형으로, 주소값이 저장된다.
- 배열의 길이 변경이 필요하면 새로운 배열을 생성하고 내용을 옮겨야 한다.

<br>

만약 배열 안의 값들을 설정하지 않고, 배열만 생성했을 경우 자료형의 초기값으로 초기화된다.

가령 int형 배열을 생성했다고 가정해보자.

```java
int[] arr = new int[10];
```

그러면 배열 arr의 값들은 int형의 초기값인 0으로 설정되어 있는 것이다.

만약 배열을 생성하고 값을 초기화하려면 다음과 같은 방식들로 배열을 생성해야 한다.

```java
자료형[] 배열이름 = new 자료형[] { 값1, 값2, 값3, 값4 };    // 배열 생성 및 값 초기화
자료형[] 배열이름 = { 값1, 값2, 값3, 값4 };     // 선언과 동시에 초기화
```

<br>

배열 안의 값들을 리스트 형식으로 쉽게 출력하는 방법은 다음과 같다.

```java
int[] arr = {1, 3, 5, 7, 9};

System.out.println(Arrays.toString(arr));
```

그러면 출력 결과는 다음과 같다.

```
[1, 3, 5, 7, 9]
```

<br>

### 배열의 복사

파이썬, 자바스크립트의 경우 배열의 길이가 바뀌는 것을 볼 수 있었다. 반면, 자바에서는 배열의 길이는 바뀌지 않는다.

만약 길이를 변경할 필요성이 생긴다면, 원하는 길이만큼 늘린 배열을 생성하고, 그 배열에 기존 배열의 내용을 복사해야 한다.

배열을 복사하는 방법은 크게 3가지가 있다.

1. 반복문을 사용해서 복사
2. ```Arrays.copyOf(복사하고_싶은_배열, 새로운_배열의_크기)```
3. ```System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)```

위 세 가지 방법들 중 두 번째와 세 번째 방법을 예시로 알아보자.

<br>

우선 두 번째 방법인 ```Arrays.copyOf(복사하고_싶은_배열, 새로운_배열의_크기)``` 방식이다.

```java
int[] nums = {2, 4, 6, 8, 10};

int[] tmp = Arrays.copyOf(nums, 10);
System.out.println(Arrays.toString(tmp));
```

위 코드의 실행 결과는 다음과 같다.

```
[2, 4, 6, 8, 10, 0, 0, 0, 0, 0]
```

<br>

다음으로 세 번째 방법인 ```System.arraycopy(원본배열, 원본배열의시작인덱스, 복사할배열의참조값, 복사할배열의시작인덱스, 복사할크기)``` 방식을 사용해보겠다.

우선 '복사할배열의참조값'을 구하기 위해, 복사할 배열을 하나 생성해야 한다.

```java
int[] nums = {2, 4, 6, 8, 10};

int[] tmp = new int[10];
System.arraycopy(nums, 0, tmp, 0, nums.length);
System.out.println(Arrays.toString(tmp));
```

위 코드의 출력 결과는 다음과 같다.

```
[2, 4, 6, 8, 10, 0, 0, 0, 0, 0]
```

<br>

### 구간합 계산하기

구간합이란, 주어진 배열에서 두 수 N, M이 주어질 때 N번 인덱스부터 M번 인덱스까지의 합을 구하는 것이다. (N <= M)

구간합을 구할 때에는 (전체를 더한 값) - (앞부분을 더한 값) 의 방식으로 구하거나, 미리 누적합(prefixSum)을 구해두고 (M의 누적합) - (N-1의 누적합) 으로 구할 수 있다.

우선 (전체를 더한 값) - (앞부분을 더한 값) 방식을 이용해서 구하는 예시를 보겠다.

```java
int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int n = 5;
int m = 8;

int A = 0;  // 0 ~ M 까지의 합
int B = 0;  // 0 ~ (N - 1) 까지의 합
for (int i = 0; i <= m; i++) {
    A += arr[i];
}
for (int i = 0; i <= n - 1; i++) {
    B += arr[i];
}
System.out.println(A - B);
```

위 코드의 출력 결과는 '30'이다. 즉, arr의 인덱스 0부터 m까지의 누적합에서 0부터 n - 1 까지의 누적합을 뺀 값이므로, 6 ~ 9를 더한 값이다. 30이 나오는 것이다.

<br>

누적합(prefixSum)을 사용한 예시는 다음과 같다.

```java
int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int n = 5;
int m = 8;
int[] prefixSum = new int[arr.length];  // 원본 배열과 똑같은 크기로 만든다.
prefixSum[0] = arr[0];
for (int i = 1; i < arr.length; i++) {
    prefixSum[i] = prefixSum[i - 1] + arr[i];
}
System.out.println(Arrays.toString(prefixSum));

System.out.println(prefixSum[m] - prefixSum[n - 1]);
```

위 코드의 출력 결과는 다음과 같다.

```
[1, 3, 6, 10, 15, 21, 28, 36, 45, 55]
30
```

<br>

### 빈도수 구하기

배열에서 '빈도수 구하기'란, 각 숫자가 출현하는 숫자를 센다는 것이다.

가령 다음과 같은 배열이 있다고 해보자.

```java
int[] arr = {1, 3, 4, 1, 2, 5, 6, 8, 9, 9, 6, 7, 8, 9, 4, 5, 2};
```

위 배열에서 5는 2번 나왔고, 9는 3번 나왔다. 이렇게 개수를 세는 것이다. 이때 이용하는 방법이 count 배열을 이용하는 것이다.

보면 위 배열 안 숫자들의 특징이 있는데, '양의 정수'라는 것이다.

우선 0부터 9까지의 배열을 생성한다.

```java
int[] count = new int[10];  // 0 1 2 3 4 5 6 7 8 9
```

배열 arr를 순회하면서 1을 만나면 그때마다 count를 늘린다. 0은 배제하고, 1부터 9까지만 보는 것이다.

코드는 다음과 같다.

```java
int[] arr = {1, 3, 4, 1, 2, 5, 6, 8, 9, 9, 6, 7, 8, 9, 4, 5, 2};

int[] count = new int[10];  // 카운팅 배열의 선언. 수의 범위: 1 ~ 9 (양의 정수). 제일 큰 수 + 1의 크기로 만들면 된다.

for (int i = 0; i < arr.length; i++) {
    count[arr[i]]++;
}

System.out.println(Arrays.toString(count));
```

위 코드의 출력 결과는 다음과 같다.

```
[0, 2, 2, 1, 2, 2, 2, 1, 2, 3]
```

1은 2번, 2는 2번, 3은 1번, ..., 9는 3번이 나온 것이다.

<br>

### 중앙값(median) 찾기

중앙값(median)이란, 배열의 크기의 순서대로 정렬했을 때 가장 중앙에 위치하는 값을 찾는 것이다. 배열의 길이가 짝수일 경우, 중앙값은 가운데에 있는 두 개의 수를 평균 낸 값이다. (홀수의 경우 중앙에 있는 값이다.)

앞서 정렬되지 않은 배열 arr를 빈도수 구하기 방식을 적용해 count 배열을 얻어냈었다. 이 count 배열은 정렬된 값을 구한 것이다.

즉, <b>빈도수를 구하는 순간 이미 정렬이 된 것</b>이다.

빈도수 구하기를 활용하면 중앙값을 구하는 것이 자동적으로 된다.

<br>

중앙값을 찾는 방법은 여러 가지가 있지만, 카운팅(빈도수 구하기) 배열을 활용해서 찾아보겠다.

```java
int[] arr = {1, 3, 4, 1, 2, 5, 6, 8, 9, 9, 6, 7, 8, 9, 4, 5, 2};

int[] count = new int[10];
for (int i = 0; i < arr.length; i++) {
    count[arr[i]]++;
}

System.out.println(Arrays.toString(count));     // 빈도수를 구한 배열 => '정렬된 값'

// 카운팅 배열로 중앙값 구하기
// 앞에서부터 개수를 누적해 나가면서
// 그 개수가 처음으로 중간을 넘어설 때, 그 수가 중간값
int sum = 0;    // 개수의 합
int median = 0;
for (int i = 1; i <= 9; i++) {
    sum += count[i];
    System.out.println("현재(" + i + ")까지 개수의 합: " + sum);
    if (sum >= arr.length / 2 + 1) {
        median = i;
        break;
    }
}
```

위 코드의 출력값은 다음과 같다.

```
[0, 2, 2, 1, 2, 2, 2, 1, 2, 3]
현재(1)까지 개수의 합: 2
현재(2)까지 개수의 합: 4
현재(3)까지 개수의 합: 5
현재(4)까지 개수의 합: 7
현재(5)까지 개수의 합: 9
```