---
layout: post
title: Union By Rank
categories: Algorithm
date: 2024-11-14 11:38:00 +0900
---
Union-Find 알고리즘을 사용할 경우, 최악의 경우 트리가 아닌 연결 리스트(Linked List)와 같은 형태가 될 수 있다. 이때는 Find/Union 시 계산량이 O(N) 이 될 수 있으므로, 이 문제를 해결하기 위해서는 <b>Union-By-Rank</b> 기법을 사용할 수 있다.

## Union-By-Rank

각 트리에 대해 높이(Rank)를 기억해 두고, Union 연산 시 두 트리의 높이가 다르면 높이가 큰 트리에 높이가 작은 트리를 붙이는 것이다.

그리고 높이가 동일한 두 개의 트리를 합칠 때에는, 한 쪽 트리 높이를 1 증가시켜주고 다른 쪽 트리를 해당 트리에 붙인다. (어느 쪽을 선택하는지는 상관없다.)

이러한 Union-By-Rank 기법을 사용하면, 높이가 h 인 트리를 만들려면 높이가 h - 1 인 트리가 두 개 필요하다. 그래야 Rank 를 1 증가시킬 수 있기 때문이다.

높이가 h - 1 인 트리를 만들기 위해서 최소 n 개의 원소가 필요하다면, 높이가 h 인 트리가 만들어지기 위해서는 최소 2 x n 개의 원소가 필요하다. (이진 트리 구조)

따라서, Union-By-Rank 기법을 사용하면, 루트 노드를 찾아가는 시간 복잡도는 O(N) 이 아닌 O(log N) 으로 낮출 수 있다.

<br>

Union-Find 알고리즘을 사용해 크루스칼(Kruskal) 알고리즘을 구현할 수 있다. 이때 다음 세 가지를 모두 사용하면, 메모리, 시간을 절약할 수 있다.

1. <b>Path Compression (경로 압축)</b>
2. <b>Union-By-Rank</b>
3. <b>heapq</b>

<a href="https://www.acmicpc.net/problem/1197">백준 1197번 최소 스패닝 트리</a> 문제를 보겠다. 위 세 가지 수단을 전부 사용한 코드는 다음과 같다.

```python
import sys
import heapq
input = sys.stdin.readline
sys.setrecursionlimit(100000)       # 백준 사이트에서는 기본적으로 재귀 한도가 10000으로 설정돼 있어서 풀어준다. 


def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])      # Path Compression (경로 압축)
    return parent[x]


def union_parent(x, y):
    xp = find_parent(x)
    yp = find_parent(y)
    if xp != yp:    # 만약 xp == yp 이면 사이클이 발생하는 것이므로, 그냥 배제한다.
        if rank[xp] < rank[yp]:     # Union-By-Rank
            parent[xp] = yp
        else:
            parent[yp] = xp
            if rank[xp] == rank[yp]:
                rank[xp] += 1
    return


V, E = map(int, input().split())
parent = [a for a in range(V + 1)]

edges = []
rank = [0 for _ in range(V + 1)]    # Rank를 초기에는 전부 0으로 초기화 한다.

total = 0

for _ in range(E):
    a, b, cost = map(int, input().split())
    heapq.heappush(edges, (cost, a, b))     # 나중에 edges.sort() 를 하여 시간과 공간을 많이 잡아먹기 보다는, 아얘 heapq.heappush() 를 사용한다.

while edges:
    cost, a, b = heapq.heappop(edges)       # heapq.heappop() 이기 때문에, 최솟값을 먼저 꺼낸다. (cost, a, b) 의 튜플인 경우, 튜플의 첫 번째 요소인 cost 가 최솟값인 것부터 꺼낸다.
    if find_parent(a) != find_parent(b):    # 사이클이 발생하지 않는 경우에만
        union_parent(a, b)
        total += cost

print(total)
```

