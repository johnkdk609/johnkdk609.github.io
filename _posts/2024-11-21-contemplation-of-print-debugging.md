---
layout: post
title: 프린트 디버깅(Print Debugging)에 대한 고찰
categories: Algorithm
date: 2024-11-21 17:35:00 +0900
---
알고리즘 문제를 풀다 보면 검증 단계 혹은 디버깅 단계에서 프린트 디버깅(Pring Debugging)을 자주 사용하게 된다.

프린트 디버깅에 대한 몇 가지 사항을 정리해보겠다.

## 가시성이 높아야 한다.

프린트 디버깅은 말 그대로 출력을 통해 내 코드가 정확히 동작하고 있는지 보는 것이다. 그렇기 때문에 한 눈에 잘 보이게 출력을 해야 한다.

* <b>특수문자를 사용하여 구분을 확실히 한다.</b>

'@', '&#60;', '&#61;', '&#62;', '~', '&#124;' 등의 특수문자들을 조합해 사용하여 한 눈에 현재 실행되는 메서드, 코드가 어디인지 쉽게 파악할 수 있다.

또, 메인 메서드에서 반복문으로 메서드를 호출하고 있다면, 한 턴이 끝나고 다음 턴으로 넘어가기 전에 '=====' 를 길게 출력하여 턴 간 구분을 가시화할 수 있다.

<br>

* <b>메서드 간, 턴 간 간격을 띄운다.</b>

메서드를 호출하고, 해당 메서드를 호출한다는 것을 문장으로 출력하여 표시해놨을 때, 모든 줄이 다 붙어 있으면 가시성이 높지 않다. 그리고 앞서 언급한 '=====' 의 구분자로 턴이 구분을 했을 때에도 앞 턴과 뒤 턴의 내용이 전부 붙어있으면 복잡해 보일 수 있다.

그래서 ```print()``` 함수를 사이사이에 한 번씩 넣어서 메서드 간, 턴 간 간격을 띄운다.

<br>

* <b>print format 함수를 사용한다.</b>

알고리즘 문제를 풀 때 매우 빈번하게 출력하는 것이 2차원 혹은 3차원 배열이다.

2차원 배열 ```arr``` 을 출력한다고 생각해보자. 만약 모든 값들의 자릿수가 같다면 ```print(*arr, sep='\n')``` 의 방식으로 간편히 출력할 수 있다. 

그런데 만약 2차원 배열 ```arr``` 안에 있는 수들의 자릿수가 다양하고, 음수가 들어있거나 심지어 ```int(21e8)``` 와 같이 매우 큰 수가 들어있다면 단순히 ```print(*arr, sep='\n')``` 의 방식으로 출력했다가는 매우 가시성이 낮은 2차원 배열이 찍힐 수 있다.

```python
arr = [
    [1, 321, 44, 85, 1, 80, 3, 67],
    [702, 294, 888, 385, 912, 871, 202, 402],
    [0, 0, 1, 5, 6, 0, 0, 2],
    [1, 0, 237, 54, 1, 23, 40, 4]
]

print(*arr, sep='\n')

"""
출력 결과

[1, 321, 44, 85, 1, 80, 3, 67]
[702, 294, 888, 385, 912, 871, 202, 402]
[0, 0, 1, 5, 6, 0, 0, 2]
[1, 0, 237, 54, 1, 23, 40, 4]
"""
```

특히 상하좌우, 대각선 움직임 등으로 트래킹을 해야 하는 경우라면 2차원 배열, 3차원 배열의 크기가 커질수록 가시성이 떨어진다.

이런 경우에는 파이썬의 print format 함수를 사용하면 된다. 현재 ```arr``` 에서 가장 높은 자릿수의 숫자가 100의 자리이니까, 넉넉하게 길이를 5로 고정해보겠다.

```python
arr = [
    [1, 321, 44, 85, 1, 80, 3, 67],
    [702, 294, 888, 385, 912, 871, 202, 402],
    [0, 0, 1, 5, 6, 0, 0, 2],
    [1, 0, 237, 54, 1, 23, 40, 4]
]

for r in range(len(arr)):
    for c in range(len(arr[r])):
        print(f'{arr[r][c]:^5}', end='')    # '^' 로 가운데 정렬
    print()

"""
출력 결과

  1   321  44   85    1   80    3   67  
 702  294  888  385  912  871  202  402 
  0    0    1    5    6    0    0    2  
  1    0   237  54    1   23   40    4  
"""
```

'<' 를 길이 앞에 붙이면 왼쪽으로 당겨지고, '^' 를 길이 앞에 붙이면 가운데 정렬이 된다. 만약 아무것도 길이 앞에 붙이지 않으면 오른쪽으로 당겨진 채 출력된다.

이렇게 파이썬의 print format 함수로 고정 길이를 설정하면 매우 깔끔하게 출력할 수 있다.

<br>

* <b>숫자나 문자를 변환하여 출력한다.</b>

마찬가지로 2차원 이상의 배열을 출력해야 하는 상황이다. 가령 최단 거리를 찾아야 하는데 더 짧은 시간이 걸리는 경우 갱신할 수 있는 visited 배열을 사용하고 있다고 해보자.

이런 문제에서는 visited 배열을 초기화할 때 각 칸의 값에 0 을 넣는 것이 아닌, 비교를 통해 '가장 작은 수' 를 찾기 위해 초기에 매우 큰 값을 넣는다. 본인은 ```int(21e8)``` 이라는 매우 큰 수를 자주 사용한다.

이제 최단 거리 테이블을 업데이트하고, 최종적으로 출력을 해본다고 해보자.

```python
INF = int(21e8)

visited = [     # 임의로 만든 INF 값이 담긴 2차원 배열
    [1, 2, 3, 4, 5],
    [2, INF, INF, 5, INF],
    [3, 4, 5, 6, 7],
    [INF, 5, 6, 7, 8],
    [7, 6, INF, INF, 9]
]

print(*visited, sep='\n')

"""
출력 결과

[1, 2, 3, 4, 5]
[2, 2100000000, 2100000000, 5, 2100000000]
[3, 4, 5, 6, 7]
[2100000000, 5, 6, 7, 8]
[7, 6, 2100000000, 2100000000, 9]
"""
```

```int(21e8)``` 이라는 숫자 자체가 자릿수가 매우 크기 때문에 2차원 배열이 찌그러진 채, 가시성이 낮게 출력된다. 그런데 INF 라는 숫자는 프린트 디버깅 과정에서 굳이 '2100000000' 이라는 숫자로 전부 출력을 할 필요가 없다. 그냥 이 지점은 '못 가는 곳' 으로 내가 알아볼 수 있게 짧게 출력하면 되는 것이다.

이렇게 굳이 원래 숫자대로 출력할 필요 없는 값이고, '못 가는 곳'으로 표시를 한다면 '*' 로 바꿔서 출력하는 방법이 있다.

```python
INF = int(21e8)

visited = [
    [1, 2, 3, 4, 5],
    [2, INF, INF, 5, INF],
    [3, 4, 5, 6, 7],
    [INF, 5, 6, 7, 8],
    [7, 6, INF, INF, 9]
]

for r in range(len(visited)):
    for c in range(len(visited[r])):
        if visited[r][c] == INF:
            print(f'*  ', end='')
        else:
            print(f'{visited[r][c]:<3}', end='')
    print()

"""
출력 결과

1  2  3  4  5  
2  *  *  5  *  
3  4  5  6  7  
*  5  6  7  8  
7  6  *  *  9
"""
```

위와 같이 INF 값을 '*' 로 변경하여 출력하면, 프린트 디버깅 과정이 훨씬 쉬울 것이다.

<br>