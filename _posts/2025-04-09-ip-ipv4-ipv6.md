---
layout: post
title: IP주소체계 &#35;1&#58; IPv4와 IPv6
categories: Network
description: CS 지식의 정석 - 디자인패턴 네트워크 운영체제 데이터베이스 자료구조
date: 2025-04-09 23:45:00 +0900
---
IPv4, IPv6 에 대해 알아보겠다.

앞서 얘기했던 것을 잠깐 복습해보자. 쿠팡에 어떤 것을 주문했을 때, 판매자는 나의 주소를 알아야 물건을 보낼 수 있다. 이와 마찬가지로 데이터도 주소를 알아야 송 &#183; 수신이 가능하다. 이러한 인터넷 상에서의 주소가 IP 주소이다. 그리고 'IP주소'라 하면 그 밑에 있는 MAC주소도 생각이 나야 하고, 그 과정인 ARP도 생각이 나야 한다.

이 IP주소에는 두 가지 버전이 있다. v4와 v6이다. 예전에는 v4 로만 했는데 지금은 v6 로 넘어가는 추세이긴 하다. 하지만 여전히 v4를 굉장히 많이 사용하고 있다. 사실 v6가 v4보다 좋은 점이 엄청 많다. 그러나 지금까지는 v4를 매우 많이 쓰고 있기 때문에 v4에 대해 심도있게 알아볼 것이다.

<br>
<hr>

## IPv4

IPv4는 32비트로 표현되는 주소체계이며 2^32개의 주소(41억 9천만 주소)를 표현할 수 있다. 8비트 단위로 점을 찍어 4개로 구분해서 표현하며 보통 8비트를 10진수로 표현해서 말한다.

이 주소 체계만으로는 부족하기 때문에 NAT, 서브네팅 여러개의 부수적인 기술이 생겨났다.

'32비트'부터 알아보자.

<img src="/assets/img/captures/ipv4-address-in-dotted-decimal-notation.jpg" width="600px" />

위 그림은 IP주소가 표현되어 있다. 10101100은 십진수로 나타내면 172가 된다. 이런 식으로 8개의 비트를 한 덩어리로 해서 총 네 덩어리 즉 32비트로 표현하는 것이다.

이때 8비트 단위를 옥텟(Octet)이라고 한다.

2^32개의 주소는 부족하다. 세계 인구가 보통 50억이 넘는다. 한 사람이 노트북, 데스크톱, 핸드폰, 아이패드 등 한 번에 여러 기기를 가지고 있을 수 있다. 이런 장치들을 사용한다고 했을 때 보통 네트워크에 연결해서 사용한다. 만약 한 명당 네 개의 기기를 가진다고 하면 200억 개가 필요한 것이다. 그래서 부족하기 때문에 NAT, 서브네팅 여러개의 부수적인 기술이 필요하다.

IP를 표현할 때 이진수로 표현할 수 있는데, IPv4에서는 편의상 십진수로 변환해서 표현한다.

<img src="/assets/img/captures/ipv4-address-4-octets.jpg" width="800px" />

8개가 옥텟이니까, IPv4는 네 개의 옥텟으로 이뤄져 있다고 보면 된다.

<br>
<hr>

## IPv6

이제는 IPv6에 대해서 알아보자.

IPv6는 128비트로 표현되는 주소체계이며 2^128개의 주소를 표현한다. (몇 경이 넘어가는 큰 수이다.)

즉, 많은 주소 처리 가능하며 NAT, 서브네팅이 필요하지 않다.

16비트씩 8개로 구분하고 16비트는 16진수로 변환되어 콜론(:)으로 구분하여 표시하며 앞의 연속되는 0은 생략될 수 있다.

<img src="/assets/img/captures/ipv6-address-in-hexadecimal.jpg" width="700px" />

IPv4에서는 십진수로 표현했는데, IPv6는 십육진수로 표현한다.

<img src="/assets/img/captures/hexadecimal_table.jpg" width="400px" />

위 표를 보자. 십진수는 0부터 9까지 가고 그 이후부터는 10, 11, 12, 13, ... 이렇게 간다면, 십육진수는 0부터 15까지 알파벳을 사용하면서 표현한다.

IPv4는 점(.)으로 구분했다면, IPv6는 콜론(:)으로 구분한다. 그리고 IPv6에서 0이 연속되는 것은 생략될 수 있다.

<br>

다음 그림은 IPv6가 어떻게 구성되어 있는지이다.

앞의 64비트는 네트워크 주소를 말하고 뒤 64비트는 인터페이스 주소로 이루어져 있다.

<img src="/assets/img/captures/ipv6-networkportion-interfaceId.jpg" width="800px" />

이 IPv6에는 IPSec이 내장되어 있다. IPSec은 데이터 패킷을 암호화 하는 보안 네트워크 프로토콜 제품군이다.

### 단순해진 헤더 포맷

그리고 IPv4 헤더의 불필요한 필드를 제거하여 보다 빠른 처리가 가능하다.

<img src="/assets/img/captures/ipv4-ipv6-header-comparison.jpg" width="800px" />

패킷마다 헤더가 있는데 IPv4의 경우 위와 같이 헤더가 구성되어 있다. 그런데 불필요한 필드가 굉장히 많다. IPv6은 이것들을 제거해서 헤더가 깔끔해진 것을 볼 수 있다.

### IPv4는 체크섬이 있지만 IPv6은 체크섬이 없다.

IPv4에는 CRC를 통한 손상된 패킷을 확인하고 폐기하는 데 쓰는 체크섬 필드가 있다. (Header Checksum 필드) 그러나 IPv6는 해당 체크섬 필드가 존재하지 않는다. 이유는 상위 프로토콜(TCP, UDP)에 체크섬 필드가 있기 때문에 헤더의 효율화를 위해 버전이 업그레이드 되면서 사라졌기 때문이다.

<img src="/assets/img/captures/tcp-header-udp-header-checksum.jpg" width="800px" />

위 그림을 보면 TCP Header, UDP Header 모두 체크섬(Checksum) 필드가 들어가 있는 것을 확인할 수 있다.

만약 체크섬 필드를 사용하지 않는 것으로 설정하고 싶다면 해당 필드의 값을 모두 0으로 만들면 된다. 이를 통해 체크섬 필드를 유동적으로 사용하거나 사용하지 않게 만들 수 있다. 다만 IPv6 + UDP로 사용할 경우 IPv6의 헤더 내의 체크섬 필드가 없기 때문에 무조건 UDP 헤더의 체크섬 필드를 사용한다고 설정해야 한다.

이 외에도 IPv4는 헤더가 가변길이이지만 IPv6는 고정길이(40바이트)라서 "인터넷 헤더 길이"에 대한 정보가 없다. (이 외에도 여러가지 불필요한 정보가 삭제되어 있다.)

>> [참고] CRC

>> 순환중복검사로 네트워크 상에서 데이터에 오류가 있는지 확인하기 위해 체크값을 결정하는 방식. 데이터를 전송하기 전에 주어진 데이터의 값에 따라 CRC 값을 계산하여 데이터에 붙여 전송하고, 데이터 전송이 끝난 후 받은 데이터의 값으로 다시 CRC 값을 계산하게 된다. 이어서 두 값을 비교하고, 이 두 값이 다르면 데이터 전송 과정에서 잡음 등에 의해 오류가 덧붙여 전송된 것임을 알 수 있다.
