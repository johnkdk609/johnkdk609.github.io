---
layout: post
title: Step 단위로 적용하는 BFS
categories: Algorithm
date: 2024-10-08 11:28:00 +0900
---
BFS 문제를 풀 때에 자주 등장하는 요구사항으로 '거리가 가장 가까운 무엇을 만나면 그것을 선택한다. 만약 그러한 것이 여러 개이면 어떠한 우선순위에 따라 선택한다' 가 있다.

즉, 최단거리에 있는 객체를 찾고, 그 객체들이 2개 이상일 경우 특정 정렬 조건을 적용하여 필요한 것을 반환하는 것이다.

일반적인 BFS 메서드를 사용해도 이러한 '최단 거리'에 있는 객체들을 찾을 수 있기는 하다. 하지만 일반적인 BFS 를 사용하여 최단 거리에 있는 객체들을 찾고 탐색을 바로 종료하는 것을 구현하려면 코드가 좀 난잡해질 수 있다.

가령 시작 지점이 ```(sr, sc)``` 일 때, 이 지점에서 거리가 1 ~ 2 까지는 아무 객체가 없다가 3 에 객체들이 있다고 해보자. 만약 일반적인 BFS 메서드로 '가장 가까운 객체'가 등장했을 때 종료하면 같은 거리에 있는 다른 객체들은 검토를 못 하여 잘못된 접근을 할 수 있다. 이러한 문제를 해결하려면 거리가 3인 객체들을 임시 리스트에 다 담고, 거리가 4가 되는 순간 종료해야 한다. 하지만 이렇게 하는 것보다 더 깔끔하게 접근하는 방법이 있다.

<br>

## Step 단위로 적용하는 BFS

BFS에서 queue 에서 ```popleft()``` 하여 값을 꺼내는 부분에서 추가적인 처리를 통해 <b>step 단위 BFS</b> 를 구현할 수 있다.

queue 에서 요소를 꺼낼 때, 일단 현재 queue 에 들어있는 요소들의 개수 즉 queue의 길이만큼 안에서 반복문을 돌게 하는 것이다. 일단 특정 길이만큼 순회를 돌기 때문에, 중간에 새로 queue 에 추가되는 것은 그 순회 사이클이 끝날 때까지 꺼내지 않게 된다.

'같은 거리'에 있는 것들만 그 사이클 내에서 꺼내고 체크를 하는 것이다. 이때 while 문 바깥에 리스트를 하나 만들어 놓는다. 그리고 while 문 안에 있는 for 문 사이클을 돌면서 막 방문한 것 즉, queue에 막 append 한 (행, 열) 좌표에 내가 찾는 객체가 있으면 리스트에 그 (행, 열) 을 append 한다.

이렇게 내부 for 문이 종료되면, 일단 같은 '최단거리' 안에 있는 요소들을 전부 체크한 것이다. 여기서 리스트에 어떤 값이 들어있다면, 리스트를 반환하고 종료한다. 만약 리스트에 값이 없다면 다음 사이클을 시작한다.

<br>

step 단위 BFS 를 코드로 구현하면 다음과 같다.

```python
from collections import deque


def oob(row, col):      # out of bounds
    return row < 0 or row >= N or col < 0 or col >= N


def bfs_using_step(sr, sc, arr):
    visited = [[0 for _ in range(N)] for _ in range(N)]     # 재방문을 막기 위한 방문 체크 배열
    queue = deque()

    step = 1        # step 사용
    visited[sr][sc] = step
    queue.append((sr, sc))

    nearest = []    # 찾는 객체가 등장하면 담기 위한 리스트

    while queue:
        step += 1   # 일단 step 을 1 증가시킨다.
        for i in range(len(queue)):     # 현재 queue 에 있는 길이만큼만 일단 순회한다.
            cr, cc = queue.popleft()
            for d in range(4):
                nr = cr + dr[d]
                nc = cc + dc[d]
                if oob(nr, nc) or visited[nr][nc] > 0:
                    continue
                visited[nr][nc] = step
                queue.append((nr, nc))
                if arr[nr][nc] == 1:    # 찾고자 하는 객체를 nearest 리스트에 담는다.
                    nearest.append((nr, nc))

        if nearest:     # 만약 리스트가 비어있지 않다면
            nearest.sort(key=lambda x: (x[0], x[1]))    # 문제 조건에 맞춰서 정렬. 지금은 임의로 '행 작은 순, 열 작은 순' 으로 정렬했다.
            return nearest[0], visited      # 찾고자 한 객체, 방문 체크 배열 반환

    return (-1, -1), visited    # 만약 찾고자 한 객체가 격자에 없으면, 그냥 (-1, -1) 반환하도록 설정


N = 9

grid = [        # 임의로 생성한 0, 1 로 이루어진 N × N 크기 격자
    [1, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 0, 1, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 1, 1, 0, 0, 0],
    [1, 1, 0, 0, 0, 0, 0, 0, 0]
]

start_r, start_c = N // 2, N // 2       # 임의로 설정한 탐색 시작 지점

# delta - 상 우 하 좌 => 문제에서 주어진 우선순위대로 배치하면 된다.
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]

ans, v = bfs_using_step(start_r, start_c, grid)
print(f'가장 가까운 거리에 있는 값 중 행 가장 작고, 열 가장 작은 것 - 행: {ans[0]}, 열: {ans[1]}')
print(*v, sep='\n')
```

위 코드의 출력 결과는 다음과 같다.

```
가장 가까운 거리에 있는 1 중 행 가장 작고, 열 가장 작은 것 - 행: 1, 열: 4
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 4, 0, 0, 0, 0]
[0, 0, 0, 4, 3, 4, 0, 0, 0]
[0, 0, 4, 3, 2, 3, 4, 0, 0]
[0, 4, 3, 2, 1, 2, 3, 4, 0]
[0, 0, 4, 3, 2, 3, 4, 0, 0]
[0, 0, 0, 4, 3, 4, 0, 0, 0]
[0, 0, 0, 0, 4, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
```

출력 결과를 보면, N × N 배열을 전부 탐색한 것이 아니고, (N // 2, N // 2) 를 시작으로 grid 에 1인 값이 나올 때까지만 탐색을 한 것을 알 수 있다.

이렇게 step 단위 BFS 를 사용하여 불필요한 탐색을 줄이고, 특정 문제 상황을 손쉽게 해결할 수 있다.