---
layout: post
title: 효율적인 화폐 구성
description: <이것이 취업을 위한 코딩 테스트다 with 파이썬> p. 226
categories: Algorithm
date: 2023-09-18 22:30:00 +0900
---
효율적인 화폐 구성 문제는 다이나믹 프로그래밍 문제이다.

이 문제는 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다. 금액 i를 만들 수 있는 최소한의 화폐 개수를 a(i), 화폐의 단위를 k라고 했을 때 다음과 같이 점화식을 작성할 수 있다. a(i - k)는 금액 (i - k)를 만들 수 있는 최소한의 화폐 개수를 의미한다.

* a(i - k)를 만드는 방법이 존재하는 경우, a(i) = min(a(i), a(i - k) + 1)
* a(i - k)를 만드는 방법이 존재하지 않는 경우, a(i) = 10,001

이 점화식을 모든 화폐 단위에 대하여 차례대로 적용하면 된다. 실제로 문제를 풀기 위해서는 가장 먼저 K의 크기만큼 리스틀 할당한다. 이후에 각 인덱스를 '금액'으로 고려하여 메모이제이션을 진행한다.

<br>

답안 코드는 다음과 같다.

```python
n, m = map(int, input().split())
coins = list()
for i in range(n):
    coins.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍 진행(Bottom Up)
d[0] = 0
for i in range(n):
    for j in range(coins[i], m + 1):
        if d[j - coins[i]] != 10001:    # (i - k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - coins[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001:   # 최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else:
    print(d[m])
```

사실 위 코드에서 d[j - arrayp[i]]가 10001인지 검사하는 부분은 사실 없어도 되는 코드인데, d[j - array[i]]가 10001의 값을 가지더라도 min(d[j], d[j - array[i]] + 1)은 항상 d[j]의 값을 반환하기 때문이다. 다만, 이해를 돕기 위해 코드에 그대로 넣어둔 것이다.

<br>

입력 예시 1

```
2 15
2
3
```

출력 예시 1

```
5
```

입력 예시 1

```
3 4
3
5
7
```

출력 예시 2

```
-1
```