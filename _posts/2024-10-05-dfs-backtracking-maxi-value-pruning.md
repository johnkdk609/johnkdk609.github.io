---
layout: post
title: 백트래킹으로 최댓값 구할 때 사용할 수 있는 가지치기(pruning) 기법
categories: Algorithm
date: 2024-10-05 23:11:00 +0900
---
DFS 백트래킹 문제를 풀 때에는 '최댓값' 혹은 '최솟값' 을 구해야 하는 경우가 많다. 이때 전역 변수로 최댓값이나 최솟값의 변수를 사용하여 기저 조건(종료 조건)에서 갱신할 수 있을 경우 갱신을 하는 방식을 많이 사용한다.

백트래킹(Backtracking) 문제를 풀 때에는 항상 시간 초과를 유의해야 한다. 로직이 정확하더라도 중복 방문이 이뤄지고 있다든지, 불필요한 탐색이 추가로 진행되고 있는지 등.. 다양한 이유로 시간이 오래 걸리고, 시간 초과로 오답이 될 수 있는 것이다.

그래서 <b>가지치기(pruning)</b>가 매우 중요하다.

특정 조건을 만족하는 경우 더 깊이를 들어가지 말고 바로 종료하는 방식으로 가지를 치는 것이다.

<br>

2차원 배열에서 각 칸에 수들이 있고, 몇 개의 칸을 정한 다음 그 칸에 있는 수들의 합을 구해야 하는 경우가 있다. 이렇게 하여 최댓값을 구해야 하는 경우에 다음과 같은 유용한 가지치기 기법을 쓸 수 있다.

1. 현재 2차원 배열에서 가장 큰 수를 찾는다.
2. 기저 조건에서 ```만약 (현재까지의 합 + 가장 큰 수 × (전체 깊이 - 현재 깊이)) 가 최댓값보다 작거나 같으면 그냥 종료(return)```한다.

즉, 어차피 더 탐색해 봤자 남은 깊이에 최댓값을 곱한 수를 더해도 현재 갱신되어 있는 최댓값보다 작거나 같다면 굳이 더 탐색을 할 필요가 없는 것이다.

<br>

<a href="https://www.acmicpc.net/problem/14500">백준 14500번 테트로미노</a> 문제에서 정확히 이러한 기법을 사용할 수 있다. 다음은 실제 코드의 일부이다. 백트래킹 메서드의 기저 조건에서 사용한다.

```python
def dfs(n, sm, row, col):
    global maxi
    if sm + (4 - n) * mx <= maxi:   # 시간을 줄이기 위한 pruning. mx 값은 현재 그리드에서 가장 큰 수.
        return
    if n == 4:
        if maxi < sm:   # maxi 업데이트
            maxi = sm
        return
```

실제로 저 코드 두 줄을 추가하여 실행 시간을 2536 ms 에서 268 ms 로 거의 1/10 로 줄였다.