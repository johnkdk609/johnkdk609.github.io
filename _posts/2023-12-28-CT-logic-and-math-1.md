---
layout: post
title: Computational Thinking - 프로그래밍과 논리 / 수학
description: SWEA Computational Thinking
date: 2023-12-28 16:56:00 +0900
---
Computational Thinking을 잘 하기 위해서는 기초 논리와 수학을 잘 할 수 있어야 한다. 

## 차례

0. 프로그래밍과 논리/수학
1. 논리와 증명
2. 수와 표현
3. 집합과 조합론
4. 기초 수식
5. 재귀
6. 동적 프로그래밍
7. 조합론 프로그램 과제
8. 기초 알고리즘 프로그램 과제

## 0. 프로그래밍과 논리/수학

프로그램의 어려운 점은 크게 2가지이다.

- 프로그래밍 언어 문법과 라이브러리 사용
- 논리 (Hard Logic)

여기서 문법과 라이브러리 사용은 <u>많이 알려진 어려운 점</u>이다. 능숙해지기 위해서 많은 훈련이 필요하다. 훈련에 비례하여 실력이 느는 경향이 있다.

## 1. 논리와 증명

<b>Hard Logic vs Soft Logic</b>

주장이 사실인지 아닌지 확인하는 방법 → 논리와 증명(역, 이, <b>대우</b>)에 대해 생각해보면 답을 구하기 쉽다. ex. 카드 문제, 맥주집 문제

맥주집 문제가 상대적으로 더 쉬웠는데, 맥주집 문제를 풀 때에는 직관을 사용했기 때문이다. <b>직관은 논리적인 느낌을 주는 것</b>이다. <u>직관의 장점은 (익숙한 상황에서) 빠르다는 것</u>이다. 반면, <u>직관의 단점은 정확하지 않다는 것</u>이 있다. (가끔은 익숙한 상황에서도 틀린다.) 또 다른 단점은 강한 착각을 일으킨다는 것이다.

<br>

<b>'inclusive or' vs 'exclusive or'</b>

inclusive or 예시 - "합격하려면 토플 500점 이상 혹은 토익 600점 이상이 필요"\
exclusive or 예시 - "복권에 당첨되면 자동차 혹은 천만원을 줍니다"

<br>

일상 생활에서는 Soft Logic이 빠르기 때문에 유용하다. 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 있다.

<b>프로그래밍은 Hard Logic을 사용한다.</b> 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것이다. 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요하다.

<br>

<b>오해의 근원 - Soft Logic으로 알고리즘을 이해하려고 하는 것!</b>

알고리즘 설명을 보고 또 봐도 이해가 안 되는 것은 증명을 안 봤기 때문이다. 증명을 봐도 이해가 안 되는 것은 직관으로 이해하려고 하기 때문이다. 가끔 직관적으로 이해되는 알고리즘이 있지만, 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능하다.

<br>

'p이면 q이다'라는 명제에서 p가 거짓이면 전체는 참이 된다. (많은 사람들이 이것을 받아들이지 못한다.) 예를 들어, 아버지가 아들에게 "이번 시험에 100점을 맞으면 치킨을 사주겠다."라고 약속을 했다고 하자. 100점을 받았는데 치킨을 사줬으면 약속을 지킨 것이다. 100점을 받았는데 치킨을 안 사주면 약속을 어긴 것이다. 그런데 100점을 못 받았을 때 안 사줬으면, 약속을 지킨 것이다. 100점을 못 받았는데 사줬으면 이것도 약속을 지킨 것이다. 100점을 받으면 사준다고 얘기했지, 100점을 못 받았을 때 안 사준다는 말은 하지 않았기 때문이다. (교육적으로 문제가 있을 뿐, 약속을 어긴 것은 아니다.)

100점을 못 받았을 때 치킨을 사주더라도 약속을 어긴 것이 아니라는 것이다. 즉, 가정이 거짓이면 전체는 항상 참이 된다.

<b>① 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.</b> → 가정이 거짓이므로 참인 문장\
<b>② 만약 19894338958945893949이 Prime Number라면, 2는 짝수이다.</b> → 앞의 숫자가 Prime Number인지 아닌지와 무관하게, 뒤쪽의 문장이 참이기 때문에 전체는 항상 참이 된다.

<br>

문제 2: p와 q가 명제이고, p → q가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?

<b>p → q가 거짓이 되는 경우는, p가 참이고 q가 거짓인 경우밖에 없다.</b> 즉, 위 문제의 문항에서 p와 q가 참인지 거짓인지 알 수가 있는 것이다.

① ~p → q (참. p → q가 거짓이기 위해선 p 참, q 거짓인 경우이다. 따라서 ~p 는 거짓이고 q 또한 거짓이므로 ~p → q는 참이다.)\
② p ∨ q (참)\
③ q → p (참. 앞부분이 거짓이니 자동으로 참)

<br>

문제 3: 다음 명제들의 역, 이, 대우를 쓰시오.

<b>기본 문장: p → q</b>\
<b>역: q → p</b>\
<b>이: ~p → ~q</b>\
<b>대우: ~q → ~p</b>

<br>

다음은 진리표를 이용해서 간단하게 명제식의 참과 거짓을 알아보겠다.

* p ∧ (q → p)

<table>
    <tr>
        <th>p q</th>
        <th>p ∧ (q → p)</th>
    </tr>
    <tr>
        <td>T T<br>T F<br>F T<br>F F</td>
        <td>F<br>T<br>F<br>F</td>
    </tr>
</table>

### 증명이란?

증명은 정확한 명제식으로 표현할 수 있는 것이어야 한다. 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있다. 증명에 대한 수많은 오해가 p → q를 p ↔︎ q와 혼동하는 것에서 일어난다.

<br>

잘못된 증명에 대해 한 번 알아보겠다.

<b>모든 당구공은 색이 같다는 다음 증명에서 잘못된 것은?</b>

- 수학적 귀납법: P(1)이 참이고, P(n) → P(n + 1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.
- 모든 자연수 n에 대해 당구공 n개가 들어있는 집합에서 그 집합에 포함된 당구공은 모두 색이 같다는 것을 증명함
- P(1): 당구공 1개가 들어있는 집합은 모두 색이 같음
- P(n)이 성립하면 P(n + 1)이 성립함을 증명하기 위해 P(n)이 참이라고 가정
- 당구공 n + 1개가 들어있는 임의의 집합을 생각함
- 이 집합에서 하나를 빼면 당구공 n개가 들어있는 집합이 되므로 지금 상황에서 모든 당구공의 색이 같음
- 방금 뺀 원소를 다시 넣고, 다른 당구공을 빼면 역시 당구공 n개가 있는 집합이 되므로 지금 상황에서도 모든 당구공의 색이 같음
- 위의 두 상황에서 처음 뺀 당구공과 두 번째로 뺀 당구공의 색이 같음을 알 수 있으므로 당구공 n + 1개가 들어있는 임의의 집합은 색이 같은 것만을 포함함

<br>

<b>당구공 Paradox</b>

대부분의 사람들이 P(n)이 참이라고 가정할 수 없다고 반론한다.

하지만 수학적 귀납법에서 필요한 것은 P(n) → P(n + 1)이 참임을 보이는 것 뿐이므로 P(n)이 정말로 참일 필요는 없다.

위 증명에서 실제로 잘못된 것은 다음 부분이다.

"위의 두 상황에서 처음 뺀 당구공과 두 번째로 뺀 당구공의 색이 같음을 알 수 있으므로 당구공 n + 1개가 들어있는 임의의 집합은 색이 같은 것만을 포함함"

처음 뺀 당구공과 두 번째로 뺀 당구공의 색이 같다는 것은 공통 부분이 있다는 것인데, 실제로 n = 1인 경우, 즉 n + 1 = 2인 경우 공통 부분이 없음.

<br>

또 다른 예를 알아보겠다. 이것도 제대로 된 증명이지만 가끔 반론이 나오는 사례이다.

<b>Infinitely Many Prime Numbers</b>

Prime Number의 개수가 유한한 k개라고 가정한다. 모든 Prime Number를 다 곱하고 1을 더한 수를 n이라고 하자. 이 수 n은 어떤 Prime으로 나누어도 나머지가 1이다. 그런데 n은 어떤 Prime보다도 크므로 합성수이다. 합성수이지만 어떤 Prime으로도 나누어지지 않으므로 모순이 발생한다.

이 증명에 대한 반론으로 몇 개의 Prime이 더 존재하면 되는 것이 아니냐는 주장이 자주 있다.

위 증명은 Prime Number가 k개이면 모순이 발생한다는 것을 증명하는 것이다. 즉, Prime Number가 k개이면 항상 거짓이므로, 이 명제가 항상 참임을 확인한 것이다. (k에 관계 없이)

즉, "Prime Number가 k개"라는 명제가 항상 거짓일 수밖에 없다!

### 수학적 귀납법

수학적 귀납법의 기본형: P(1)이 참이고, P(n) → P(n + 1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.

수학적 귀납법의 강한 형태: P(1)이 참이고, P(1) ∧ P(2) ∧ ... ∧ P(n) → P(n + 1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.

<br>

다음 함수가 1부터 x까지의 합을 계산함을 증명해 보자.

High-level 증명에서는 1부터 x까지 합의 정의 중 하나인 S(n) = S(n - 1) + n을 그대로 코딩한 것이므로 증명이 된 것이라고 말하는 경우가 많다.

상세한 증명을 하려면 단순히 "답이 맞는 것이 당연하다" 라고 말하는 것으로는 충분하지 않다.

증명이 가능한 명제를 만들어야 한다. ("당연하다"를 Hard Logic으로 증명할 방법이 없다.)

이 경우 증명이 가능한 명제는 다음과 같음: "sum(x)가 리턴하는 값은 1 + 2 + ... + x의 값과 항상 같다"

이제 수학적 귀납법을 적용할 수 있다.

- P(1)이 참이다: "sum(1)이 리턴하는 값은 1이다"를 증명하면 됨. 실제 코드에 1을 대입하면 1을 리턴함을 알 수 있다.
- P(x) → P(x + 1)이 참이다: "sum(x - 1)이 1 + 2 + ... + (x - 1)을 리턴하면 sum(x)는 1 + 2 + ... + x를 리턴한다"를 증명하면 됨.
- 코드를 보면 sum(x)는 x + sum(x - 1)의 값을 리턴함. sum(x - 1)의 리턴 값은 1 + 2 + ... + (x - 1)과 같다고 가정했으므로 sum(x)는 1 + 2 + ... + (x - 1) + x = 1 + 2 + ... + x를 리턴함을 확인할 수 있음
- sum(x - 1)을 블랙박스로 보는 것이 이해에 도움을 줄 때가 있음.

### 버블 소트의 증명

High-level 증명에서는 소팅이 된다는 것을 직관적인 수준에서 설명하는 경우가 많다. 상세한 증명을 위해서는 증명이 가능한 명제가 필요하다.

배열 A[1], A[2], ... , A[n]을 소팅하는 알고리즘의 정확성을 증명하려고 한다면, 증명이 가능한 명제는 다음과 같을 것임: "A[1] < A[2] < ... < A[n]"

버블 소트가 정확함을 어떻게 증명할 지 생각해보자...

### 중요!

상세한 증명에 대한 경험이 없는 경우가 많고, 상세한 증명 없이는 확인하거나 이해할 수 없는 문제들이 많으므로 연습 문제들은 상세한 증명을 제시하는 것을 목표로 한다.