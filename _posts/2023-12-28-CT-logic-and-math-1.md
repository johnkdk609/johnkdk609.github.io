---
layout: post
title: Computational Thinking - 프로그래밍과 논리 / 수학 1차시
description: SWEA Computational Thinking
date: 2023-12-28 16:56:00 +0900
---
Computational Thinking을 잘 하기 위해서는 기초 논리와 수학을 잘 할 수 있어야 한다. 

## 차례

0. 프로그래밍과 논리/수학
1. 논리와 증명
2. 수와 표현
3. 집합과 조합론
4. 기초 수식
5. 재귀
6. 동적 프로그래밍
7. 조합론 프로그램 과제
8. 기초 알고리즘 프로그램 과제

## 0. 프로그래밍과 논리/수학

프로그램의 어려운 점은 크게 2가지이다.

- 프로그래밍 언어 문법과 라이브러리 사용
- 논리 (Hard Logic)

여기서 문법과 라이브러리 사용은 <u>많이 알려진 어려운 점</u>이다. 능숙해지기 위해서 많은 훈련이 필요하다. 훈련에 비례하여 실력이 느는 경향이 있다.

## 1. 논리와 증명

<b>Hard Logic vs Soft Logic</b>

주장이 사실인지 아닌지 확인하는 방법 → 논리와 증명(역, 이, <b>대우</b>)에 대해 생각해보면 답을 구하기 쉽다. ex. 카드 문제, 맥주집 문제

맥주집 문제가 상대적으로 더 쉬웠는데, 맥주집 문제를 풀 때에는 직관을 사용했기 때문이다. <b>직관은 논리적인 느낌을 주는 것</b>이다. <u>직관의 장점은 (익숙한 상황에서) 빠르다는 것</u>이다. 반면, <u>직관의 단점은 정확하지 않다는 것</u>이 있다. (가끔은 익숙한 상황에서도 틀린다.) 또 다른 단점은 강한 착각을 일으킨다는 것이다.

<br>

<b>'inclusive or' vs 'exclusive or'</b>

inclusive or 예시 - "합격하려면 토플 500점 이상 혹은 토익 600점 이상이 필요"\
exclusive or 예시 - "복권에 당첨되면 자동차 혹은 천만원을 줍니다"

<br>

일상 생활에서는 Soft Logic이 빠르기 때문에 유용하다. 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 있다.

<b>프로그래밍은 Hard Logic을 사용한다.</b> 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것이다. 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요하다.

<br>

<b>오해의 근원 - Soft Logic으로 알고리즘을 이해하려고 하는 것!</b>

알고리즘 설명을 보고 또 봐도 이해가 안 되는 것은 증명을 안 봤기 때문이다. 증명을 봐도 이해가 안 되는 것은 직관으로 이해하려고 하기 때문이다. 가끔 직관적으로 이해되는 알고리즘이 있지만, 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능하다.

<br>

'p이면 q이다'라는 명제에서 p가 거짓이면 전체는 참이 된다. (많은 사람들이 이것을 받아들이지 못한다.) 예를 들어, 아버지가 아들에게 "이번 시험에 100점을 맞으면 치킨을 사주겠다."라고 약속을 했다고 하자. 100점을 받았는데 치킨을 사줬으면 약속을 지킨 것이다. 100점을 받았는데 치킨을 안 사주면 약속을 어긴 것이다. 그런데 100점을 못 받았을 때 안 사줬으면, 약속을 지킨 것이다. 100점을 못 받았는데 사줬으면 이것도 약속을 지킨 것이다. 100점을 받으면 사준다고 얘기했지, 100점을 못 받았을 때 안 사준다는 말은 하지 않았기 때문이다. (교육적으로 문제가 있을 뿐, 약속을 어긴 것은 아니다.)

100점을 못 받았을 때 치킨을 사주더라도 약속을 어긴 것이 아니라는 것이다. 즉, 가정이 거짓이면 전체는 항상 참이 된다.

<b>① 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.</b> → 가정이 거짓이므로 참인 문장\
<b>② 만약 19894338958945893949이 Prime Number라면, 2는 짝수이다.</b> → 앞의 숫자가 Prime Number인지 아닌지와 무관하게, 뒤쪽의 문장이 참이기 때문에 전체는 항상 참이 된다.

<br>

문제 2: p와 q가 명제이고, p → q가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?

<b>p → q가 거짓이 되는 경우는, p가 참이고 q가 거짓인 경우밖에 없다.</b> 즉, 위 문제의 문항에서 p와 q가 참인지 거짓인지 알 수가 있는 것이다.

① ~p → q (참)\
② p ∨ q (참)\
③ q → p (참. 앞부분이 거짓이니 자동으로 참)

<br>

문제 3: 다음 명제들의 역, 이, 대우를 쓰시오.

<b>기본 문장: p → q</b>\
<b>역: q → p</b>\
<b>이: ~p → ~q</b>\
<b>대우: ~q → ~p</b>

<br>

다음은 진리표를 이용해서 간단하게 명제식의 참과 거짓을 알아보겠다.

1. p ∧ (q → p)

<table>
    <tr>
        <th>p q</th>
        <th>p ∧ (q → p)</th>
    </tr>
    <tr>
        <td>T T<br>T F<br>F T<br>F F</td>
        <td>F<br>T<br>F<br>F</td>
    </tr>
</table>

2. (p ∧ ~q) → r

