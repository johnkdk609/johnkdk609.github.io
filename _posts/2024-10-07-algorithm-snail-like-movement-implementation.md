---
layout: post
title: 달팽이 움직임 구현
categories: Algorithm
date: 2024-10-07 22:27:00 +0900
---
알고리즘 문제를 풀다 보면 달팽이(snail)의 모양으로 움직이는 객체가 자주 등장한다. 가령 2차원 배열의 중심에서, 시계방향으로 점점 반지름을 키워가며 채워 나가는 것이다.

'달팽이 기법'을 구현하는 방법은 다양하다. 그런데 나는 나만의 기법이 있다.

## 시계방향 확산 달팽이

N × N 크기의 2차원 배열이 있고, 중앙에서 시작해 시계방향으로 점점 커지는 달팽이가 있다고 하자. (N은 3 이상의 홀수이다.) 처음 중앙에서는 바로 위 방향으로 시작한다. 그리고 2차원 배열의 (0, 0) 지점에 도달하면 종료된다.

이러한 달팽이를 구현하려면, 한 칸 움직일 때마다 <b>"오른쪽으로 방향을 꺾을 수 있으면 꺾고, 불가능하면 직진한다"</b> 를 체크하면 된다.

방문 체크 배열(visited 배열)을 사용하여 방문한 지점마다 방문 체크를 하면서, 한 칸 움직일 때마다 오른쪽으로 꺾어서 한 칸 간 곳이 아직 방문하지 않은 곳인지 보는 것이다. 이러한 로직으로 작동하기 때문에 '시계방향 확산 달팽이' 에서는 경계 체크(out of bounds)를 따로 하지 않아도 된다. 그냥 현재 지점이 (0, 0) 에 도달하면 종료하거나 다른 작업을 하면 되는 것이다.

이러한 로직으로 작성한 시계방향 확산 달팽이는 다음과 같다.

```python
def clockwise_spreading_snail(v):
    global sr, sc, cur_d
    nr = sr + dr[cur_d]
    nc = sc + dc[cur_d]
    sr, sc = nr, nc     # 달팽이의 행, 열 좌표 업데이트
    v[sr][sc] = 1       # 외부에서 받은 방문 체크 배열에 한 칸 나아간 지점 방문 체크

    # 이제 오른쪽으로 방향 꺾을 수 있는지 여부 파악한다.
    tmp_d = (cur_d + 1) % 4
    nr = sr + dr[tmp_d]
    nc = sc + dc[tmp_d]
    if v[nr][nc] == 0:      # 오른쪽으로 꺾고 한 칸 진행했는데 방문한 적 없는 곳이면, 방향을 바로 꺾는다.
        cur_d = tmp_d

    return v


N = 3   # 3 이상의 홀수 값 아무거나 설정하면 된다.
visited = [[0 for _ in range(N)] for _ in range(N)]

sr, sc = N // 2, N // 2     # 시작 지점 - 2차원 배열의 정중앙
cur_d = 0                   # 현재 방향 (↑)

# delta - 상 우 하 좌 (시계방향)
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]

visited[sr][sc] = 1     # 일단 시작 지점 (정중앙) 방문 체크

dir_dict = {
    0: '↑', 1: '→', 2: '↓', 3: '←'
}

while True:
    visited = clockwise_spreading_snail(visited)
    print(*visited, sep='\n')
    print('현재 바라보는 방향:', dir_dict[cur_d])
    print('====================')
    if sr == 0 and sc == 0:
        break
```

위 코드의 출력 결과는 다음과 같다. 

```
[0, 1, 0]
[0, 1, 0]
[0, 0, 0]
현재 바라보는 방향: →
====================
[0, 1, 1]
[0, 1, 0]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[0, 1, 1]
[0, 1, 1]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[0, 1, 1]
[0, 1, 1]
[0, 0, 1]
현재 바라보는 방향: ←
====================
[0, 1, 1]
[0, 1, 1]
[0, 1, 1]
현재 바라보는 방향: ←
====================
[0, 1, 1]
[0, 1, 1]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
[0, 1, 1]
[1, 1, 1]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
[1, 1, 1]
[1, 1, 1]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
```

정중앙 (N // 2, N // 2) 에서 시작해서 시계방향으로 달팽이와 같이 움직이는 것을 파악할 수 있다. 메인에서 현재 지점이 (0, 0) 이면 while 문을 break 하도록 설정했다.

dir_dict 라는 딕셔너리를 생성해서 한 칸 움직인 다음 바로 어느 방향을 바라보고 있는지 출력했다.

<br>

## 반시계방향 수렴 달팽이

N × N 크기의 2차원 배열이 있고, (0, 0) 에서 시작해 반시계방향으로 점점 작아지는 달팽이가 있다고 하자. (N은 3 이상의 홀수이다.) 처음 (0, 0) 에서는 바로 아래 방향으로 시작한다. 그리고 2차원 배열의 정중앙 지점인 (N // 2, N // 2) 에 도달하면 종료된다.

이러한 달팽이를 구현하려면, 한 칸 움직일 때마다 <b>"직진할 수 있으면 직진하고, 불가능하면 왼쪽으로 방향을 꺾는다"</b> 를 체크하면 된다.

방문 체크 배열(visited 배열)을 사용하여 방문한 지점마다 방문 체크를 하면서, 한 칸 움직일 때마다 한 칸 더 같은 방향으로 나아가, 한 칸 더 나아간 곳이 아직 방문하지 않은 곳인지, 아니면 경계를 벗어나는 것은 아닌지 체크하면 되는 것이다. 이러한 로직으로 작동하기 때문에 '반시계방향 수렴 달팽이' 에서는 매번 경계 체크(out of bounds)를 해야 된다. 그리고 현재 지점이 2차원 배열의 정중앙인 (N // 2, N // 2) 에 도달하면 종료한다.

이러한 로직으로 작성한 반시계방향 수렴 달팽이는 다음과 같다.

```python
def oob(row, col):      # out of bounds
    return row < 0 or row >= N or col < 0 or col >= N


def counter_clockwise_converging_snail(v):
    global sr, sc, cur_d
    nr = sr + dr[cur_d]
    nc = sc + dc[cur_d]
    sr, sc = nr, nc     # 달팽이의 행, 열 좌표 업데이트
    v[sr][sc] = 1       # 외부에서 받은 방문 체크 배열에 한 칸 나아간 지점 방문 체크

    # 이제 같은 방향으로 한 칸 더 나아갈 수 있는지 여부 파악한다.
    nr = sr + dr[cur_d]
    nc = sc + dc[cur_d]
    if oob(nr, nc) or v[nr][nc] == 1:   # 만약 한 칸 더 직진했는데, 경계를 벗어나거나 이미 방문한 지점이면 방향을 왼쪽으로 꺾는다.
        cur_d = (cur_d - 1) % 4         # dr, dc 가 상-우-하-좌 순이므로, 방향 왼쪽으로 꺾으려면 -1 을 해줘야 한다.

    return v


N = 3   # 3 이상의 홀수 값 아무거나 설정하면 된다.
visited = [[0 for _ in range(N)] for _ in range(N)]

sr, sc = 0, 0       # 시작 지점 - 2차원 배열의 정중앙
cur_d = 2           # 현재 방향 (↓)

# delta - 상 우 하 좌 (시계방향)
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]

visited[sr][sc] = 1     # 일단 시작 지점 (정중앙) 방문 체크

dir_dict = {
    0: '↑', 1: '→', 2: '↓', 3: '←'
}

while True:
    visited = counter_clockwise_converging_snail(visited)
    print(*visited, sep='\n')
    print('현재 바라보는 방향:', dir_dict[cur_d])
    print('====================')
    if sr == N // 2 and sc == N // 2:
        break
```

위 코드의 출력 결과는 다음과 같다.

```
[1, 0, 0]
[1, 0, 0]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[1, 0, 0]
[1, 0, 0]
[1, 0, 0]
현재 바라보는 방향: →
====================
[1, 0, 0]
[1, 0, 0]
[1, 1, 0]
현재 바라보는 방향: →
====================
[1, 0, 0]
[1, 0, 0]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
[1, 0, 0]
[1, 0, 1]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
[1, 0, 1]
[1, 0, 1]
[1, 1, 1]
현재 바라보는 방향: ←
====================
[1, 1, 1]
[1, 0, 1]
[1, 1, 1]
현재 바라보는 방향: ↓
====================
[1, 1, 1]
[1, 1, 1]
[1, 1, 1]
현재 바라보는 방향: →
====================
```

마찬가지로 한 칸 움직인 다음 현재 바라보고 있는 방향을 쉽게 알아보기 위해 dir_dict 라는 딕셔너리를 사용했다. 방향을 꺾어야 하는 지점에서는 바로 꺾고 그 쪽을 바라보고 있는 것을 알 수 있다.

dr, dc 가 상, 우, 하, 좌로 시계방향으로 설정되어 있기 때문에, 방향을 왼쪽으로 꺾을 때에는 ```cur_d = (cur_d - 1) % 4``` 를 해줘야 한다.

<br>

## 시계방향 확산 달팽이와 반시계방향 수렴 달팽이를 연결해서 구현해야 하는 경우

위에서 작성한 달팽이들은 각각 현재 좌표가 (0, 0) 혹은 (N // 2, N // 2) 에 도달했을 때 탐색을 종료했다.

그런데 어떤 문제들은 정중앙에서 시작해 시계방향 확산 달팽이의 움직임을 하다가, (0, 0) 에 도달하면 다시 정중앙으로 반시계방향 수렴 달팽이를 해야 하는 경우가 있다. 정중앙에 도달하면 또 다시 방향을 틀어서 (0, 0) 으로 향해 가는 것이다.

이러한 경우에는 현재 어떤 상태인지 즉, '시계방향 확산 달팽이'인지 '반시계방향 수렴 달팽이'인지 체크하는 변수를 사용하면 된다.

<a href="https://www.codetree.ai/training-field/frequent-problems/problems/hide-and-seek/description?page=4&pageSize=5">코드트리 술래잡기</a> 문제에서 술래는 정확히 이러한 방식으로 이동한다.

이러한 연속적인 달팽이를 구현한 코드는 다음과 같다.

```python
# 현재 어떤 달팽이인지 체크하기 위해 상태 정보를 담은 status 변수를 사용한다. status 가 1 이면 시계방향 확산 달팽이, 2 이면 반시계방향 수렴 달팽이이다.

def oob(row, col):      # out of bounds
    return row < 0 or row >= N or col < 0 or col >= N


def snail_move(v):
    global sr, sc, snail_d, status      # 필요한 경우 변경될 것이기 때문에 전역변수로 사용
    if status == 1:     # 중앙에서 시작하는 시계방향 확산 달팽이
        nr = sr + dr[snail_d]
        nc = sc + dc[snail_d]
        sr, sc = nr, nc     # 달팽이 위치 업데이트
        v[sr][sc] = 1
        # 만약 (0, 0) 지점 도달했으면 그냥 status 바꾼다.
        if nr == 0 and nc == 0:
            status = 2
            snail_d = 2     # 방향은 아래쪽으로 꺾어놓는다.
            v = [[0 for _ in range(N)] for _ in range(N)]
            v[0][0] = 1
            return v
        # 이제 오른쪽으로 꺾을 수 있는지 체크한다.
        tmp_d = (snail_d + 1) % 4
        nr = sr + dr[tmp_d]
        nc = sc + dc[tmp_d]
        if v[nr][nc] == 0:
            snail_d = tmp_d

    elif status == 2:   # (0, 0) 에서 시작하는 반시계방향 수렴 달팽이
        nr = sr + dr[snail_d]
        nc = sc + dc[snail_d]
        v[nr][nc] = 1
        sr, sc = nr, nc

        # 경계체크 및 visited 배열 체크를 해야 한다.
        nr = sr + dr[snail_d]
        nc = sc + dc[snail_d]
        if oob(nr, nc) or v[nr][nc] == 1:
            snail_d = (snail_d - 1) % 4

        # 정중앙 지점에 도달하면 status 바꾼다.
        if sr == N // 2 and sc == N // 2:
            status = 1
            snail_d = 0
            v = [[0 for _ in range(N)] for _ in range(N)]
            v[N // 2][N // 2] = 1

    return v


N = 3       # 3 이상의 홀수

sr, sc = N // 2, N // 2     # 처음에는 2차원 배열의 정중앙에서 시작한다.

# 방향 delta - 상 우 하 좌
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]

visited = [[0 for _ in range(N)] for _ in range(N)]
status = 1      # 시작은 중앙에서 시작하는 정방향
visited[sr][sc] = 1
snail_d = 0     # 달팽이 시작 방향은 위쪽 (↑)

dir_dict = {
    0: '↑', 1: '→', 2: '↓', 3: '←'
}

for k in range(20):     # 임의로 몇 턴 움직일 것인지 설정
    visited = snail_move(visited)
    print(*visited, sep='\n')
    print('현재 바라보는 방향:', dir_dict[snail_d])
    print('====================')
```

위 코드의 출력 결과는 다음과 같다. 임의로 20턴 움직이게 하였다.

```
[0, 1, 0]
[0, 1, 0]
[0, 0, 0]
현재 바라보는 방향: →
====================
[0, 1, 1]
[0, 1, 0]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[0, 1, 1]
[0, 1, 1]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[0, 1, 1]
[0, 1, 1]
[0, 0, 1]
현재 바라보는 방향: ←
====================
[0, 1, 1]
[0, 1, 1]
[0, 1, 1]
현재 바라보는 방향: ←
====================
[0, 1, 1]
[0, 1, 1]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
[0, 1, 1]
[1, 1, 1]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
[1, 0, 0]
[0, 0, 0]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[1, 0, 0]
[1, 0, 0]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[1, 0, 0]
[1, 0, 0]
[1, 0, 0]
현재 바라보는 방향: →
====================
[1, 0, 0]
[1, 0, 0]
[1, 1, 0]
현재 바라보는 방향: →
====================
[1, 0, 0]
[1, 0, 0]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
[1, 0, 0]
[1, 0, 1]
[1, 1, 1]
현재 바라보는 방향: ↑
====================
[1, 0, 1]
[1, 0, 1]
[1, 1, 1]
현재 바라보는 방향: ←
====================
[1, 1, 1]
[1, 0, 1]
[1, 1, 1]
현재 바라보는 방향: ↓
====================
[0, 0, 0]
[0, 1, 0]
[0, 0, 0]
현재 바라보는 방향: ↑
====================
[0, 1, 0]
[0, 1, 0]
[0, 0, 0]
현재 바라보는 방향: →
====================
[0, 1, 1]
[0, 1, 0]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[0, 1, 1]
[0, 1, 1]
[0, 0, 0]
현재 바라보는 방향: ↓
====================
[0, 1, 1]
[0, 1, 1]
[0, 0, 1]
현재 바라보는 방향: ←
====================
```

status 라는 변수를 임의로 설정해서, 1 일 경우 시계방향 확산 달팽이 움직임, 2일 경우 반시계방향 수렴 달팽이 움직임을 하게 하였다. 시계방향 확산 달팽이 움직임을 하다가, (0, 0) 을 만나는 순간 visited 배열을 0 으로 초기화 하고 (0, 0) 지점을 방문 체크한 다음, 현재 방향을 아래를 보게 변환했다. 반시계방향 수렴 달팽이 움직임을 하다가 (N // 2, N // 2) 에 도달하는 순간 visited 배열을 0 으로 초기화 하고 (N // 2, N // 2) 지점을 방문 체크한 다음, 현재 방향을 위로 보도록 변환했다.

마찬가지로 dir_dict 를 사용하여 한 칸 이동한 후 어느 방향을 바라보고 있는지 함께 출력했다.