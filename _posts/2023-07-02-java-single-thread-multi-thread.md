---
layout: post
title: 싱글쓰레드와 멀티쓰레드
description: Java의 정석 기초편 ch. 13 쓰레드
categories: Java
date: 2023-07-02 12:46:00 +0900
---
앞에서 멀티쓰레드 프로세스가 가진 장점을 간단히 설명했는데, 이번에는 예제를 통해서 싱글쓰레드 프로세스와 멀티쓰레드 프로세스의 차이를 보다 깊이 있게 이해할 수 있도록 하고자 한다.

두 개의 작업을 하나의 쓰레드(th1)로 처리하는 경우와 두 개의 쓰레드(th1, th2)로 처리하는 경우를 가정해보자. 하나의 쓰레드로 두 작업을 처리하는 경우는 한 작업을 마친 후에 다른 작업을 시작하지만, 두 개의 쓰레드로 작업 하는 경우에는 짧은 시간동안 2개의 쓰레드(th1, th2)가 번갈아 가면서 작업을 수행해서 동시에 두 작업이 처리되는 것과 같이 느끼게 한다.

<img width="350" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/90c756ae-65c4-4081-ba2e-a1bd938345b8">

(a) 하나의 쓰레드로 두 개의 작업을 수행하는 경우

<img width="350" alt="image" src="https://github.com/johnkdk609/johnkdk609.github.io/assets/88493727/2a7b12f4-cc19-469b-9ec8-69ea0ce802d6">

(b) 두 개의 쓰레드로 두 개의 작업을 수행하는 경우

위 그림들은 싱글쓰레드 프로세스와 멀티쓰레드 프로세스의 비교(싱글 코어)이다.

위의 그래프에서 알 수 있듯이 하나의 쓰레드로 두 개의 작업을 수행한 시간과 두 개의 쓰레드로 두 개의 작업을 수행한 시간은 거의 같다. 오히려 두 개의 쓰레드로 작업한 시간이 싱글쓰레드로 작업한 시간보다 더 걸리게 되는데 그 이유는 쓰레드간의 작업 전환(context switching)에 시간이 걸리기 때문이다.

작업 전환을 할 때는 현재 진행 중인 작업의 상태, 예를 들면 다음에 실행되어야할 위치(PC, 프로그램 카운터) 등의 정보를 저장하고 읽어오는 시간이 소요된다. 참고로 쓰레드의 스위칭에 비해 프로세스의 스위칭이 더 많은 정보를 저장해야 하므로 더 많은 시간이 소요된다.

(프로세스 또는 쓰레드 간의 작업 전환을 '컨텍스트 스위칭(context switching)'이라고 한다.)

그래서 싱글 코어에서 단순히 CPU만을 사용하는 계산작업이라면 오히려 멀티쓰레드보다 싱글쓰레드로 프로그래밍하는 것이 더 효율적이다.


## 싱글쓰레드와 멀티쓰레드 예제 1

```java
class Ex13_2 {
	public static void main(String args[]) {
		long startTime = System.currentTimeMillis();

		for(int i=0; i < 300; i++)
			System.out.printf("%s", new String("-"));		

		System.out.print("소요시간1:" +(System.currentTimeMillis()- startTime)); 

		for(int i=0; i < 300; i++) 
			System.out.printf("%s", new String("|"));		

 		System.out.print("소요시간2:"+(System.currentTimeMillis() - startTime));
	}
}
```

위 코드의 출력 결과는 다음과 같다.

```
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------소요시간1:42||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||소요시간2:54
```

'-'를 출력하는 작업과 '|'를 출력하는 작업을 하나의 쓰레드가 연속적으로 처리하는 시간을 측정하는 예제이다. 수행 시간을 측정하기 쉽게 "-" 대신 'new String("-")'를 사용해서 수행 속도를 늦췄다.

```java
System.out.println("%s", new String("-"));      // "-" 대신, new String("-") 사용
```

컴퓨터의 성능이나 실행 환경에 의해서 실행 결과는 달라질 수 있다.

이제 새로운 쓰레드를 하나 생성해서 두 개의 쓰레드가 작업을 하나씩 나누어서 수행한 후 실행 결과를 비교해보겠다.


## 싱글쓰레드와 멀티쓰레드 예제 2

```java
class Ex13_3 {
	static long startTime = 0;

	public static void main(String args[]) {
		ThreadEx3_1 th1 = new ThreadEx3_1();
		th1.start();
		startTime = System.currentTimeMillis();

		for(int i=0; i < 300; i++)
			System.out.printf("%s", new String("-"));	

		System.out.print("소요시간1:" + (System.currentTimeMillis() - Ex13_3.startTime));
	} 
}

class ThreadEx3_1 extends Thread {
	public void run() {
		for(int i=0; i < 300; i++)
			System.out.printf("%s", new String("|"));	

		System.out.print("소요시간2:" + (System.currentTimeMillis() - Ex13_3.startTime));
	}
}
```

위 코드의 출력 결과는 다음과 같다.

```
--------||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||-------------------------------------------------------------------------------------------------------|||||||||||||||||||||||||||||||||||-||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||-|-|-|||||||||||||||||------------------------------------------------------------------------------------------------------------------|||||||||||||-|-|-|--||||||||||||||-----------------------------------소요시간2:60-------------------------------소요시간1:61
```

(멀티코어에서 실행한 결과이다.)

이전 예제와 달리 두 작업이 아주 짧은 시간동안 번갈아가면서 실행되었으며 거의 동시에 작업이 완료되었음을 알 수 있다.

이 예제 역시 컴퓨터의 성능이나 실행환경에 의해서 실행 결과는 달라질 수 있다.

두 개의 쓰레드로 작업하는데도 더 많은 시간이 걸린 이유는 두 가지이다. 하나는 두 쓰레드가 번갈아가면서 작업을 처리하기 때문에 쓰레드간의 작업전환시간이 소요되기 때문이고, 나머지 하나는 한 쓰레드가 화면에 출력하고 있는 동안 다른 쓰레드는 출력이 끝나기를 기다려야 하는데, 이때 발생하는 대기시간 때문이다.

싱글 코어인 경우에는 멀티쓰레드라도 하나의 코어가 번갈아가면서 작업을 수행하는 것이므로 두 작업이 절대 겹치지 않는다. 그러나 멀티 코어에서는 멀티쓰레드로 두 작업을 수행하면, 동시에 두 쓰레드가 수행될 수 있으므로 두 작업이 겹치는 부분이 발생한다. 그래서 화면(console)이라는 자원을 놓고 두 쓰레드가 경쟁하게 되는 것이다.

위의 결과는 실행할 때마다 다른 결과를 얻을 수 있는데 그 이유는 실행 중인 예제 프로그램(프로세스)이 OS의 프로세스 스케줄러의 영향을 받기 때문이다. JVM의 쓰레드 스케줄러에 의해서 어떤 쓰레드가 얼마나 실행될 것인지 결정되는 것과 같이 프로세스도 프로세스 스케줄러에 의해서 실행순서와 실행시간이 결정되기 때문에 매 순간 상황에 따라 프로세스에게 할당되는 실행시간이 일정하지 않고 쓰레드에게 할당되는 시간 역시 일정하지 않게 된다. 그래서 쓰레드가 이러한 불확실성을 가지고 있다는 것을 염두에 두어야 한다.

자바가 OS(플랫폼) 독립적이라고 하지만 실제로는 OS종속적인 부분이 몇 가지 있는데 쓰레드도 그 중의 하나이다.

(JVM의 종류에 따라 쓰레드 스케줄러의 구현 방법이 다를 수 있기 때문에 멀티쓰레드로 작성된 프로그램을 다른 종류의 OS에서도 충분히 테스트해볼 필요가 있다.)