---
layout: post
title: HTTP
categories: Spring-SpringBoot
date: 2024-04-09 12:34:00 +0900
---
HTTP에 대해서 간단히 알아보겠다.

<br>

그런데 그 전에 요청과 응답에 대한 흐름을 무조건 설명할 수 있어야 한다.

클라이언트와 서버가 있을 때, 클라이언트가 등록(regist)을 하려고 했을 때 어떤 식으로 이 흐름이 동작하는지 알고 있어야 하는 것이다.

등록하기 위해서는 form도 내려오고, 그 안에서 내부적으로 어떤 데이터를 가지고 포워딩(forwarding)을 할 수도 있고 아니면 서버 쪽에서 "리다이렉트 해"라고 해서 클라이언트가 다시 한 번 요청을 날릴 수도 있다.

<br>

## 인터넷 프로토콜

HTTP는 통신 규약으로, <u>인터넷 프로토콜</u>이다. 

인터넷 프로토콜이란 인터넷에서 데이터 통신을 하기 위한 표준화된 규약이나 규칙이다.

대표적으로 TCP, UDP가 있다.

* <b>TCP (Transmission Control Protocol)</b> - TCP는 나와 상대방이 서로 연결을 확인하는 것이다. 3 Way Hanshake를 통해 서로 연결을 확인하고 데이터를 보내는 것으로, 이로 인해 순서가 보장이 되고 신뢰할 수 있다. 현재 대부분의 인터넷 프로토콜에서 TCP를 사용한다.
* <b>UDP (User Datagram Protocol)</b> - 연결을 확인하지 않고 그냥 다 보낸다. 그래서 순서가 엄밀히 보장이 되지는 않는다. 하지만 냅다 보내기 때문에 빠르다.

<br>

통신을 하는 규격에는 HTTP, HTTPS(기존 HTTP에 보안이 더 고려된 것), FTP(파일 전송에 사용됨), SMTP(이메일 전송에 사용됨) 등 다양한 것들이 있다.

<br>

## HTTP (HyperText Transfer Protocol)

HTTP는 웹 서버와 웹 브라우저 간의 통신에 사용된다. 즉, 클라이언트 - 서버 구조를 가지고 있다는 것이다. 클라이언트 역할을 현재 하는 것은 내가 쓰는 크롬 브라우저이고, 서버는 WAS Tomcat 서버에다가 보내고 있는 구조이다.

HTTP로 HTML, IMAGE, VIDEO, JSON 등 다양한 데이터를 전송할 수 있다.

그리고 기본 포트번호는 80이다. 가령 ```http://localhost```로 80을 따로 입력하지 않으면, 그냥 80번 포트인 기본 포트로 가게 되는 것이다.

보안이 강조된 버전인 HTTPS (HyperText Transfer Protocol Secure) 가 있다. (요즘에는 거의 대부분의 사이트에서 HTTPS가 사용되고 있다.) 그리고 HTTPS의 기본 포트번호는 443이다.

<br>

## HTTP 특징

### 비 연결성 (Connectionless)

HTTP는 '<b>비 연결성(Connectionless)</b>'이라는 특징을 지닌다. 지속적인 연결 유지로 인한 자원 낭비를 방지하기 위해 연결을 해제하는 것이다. 

서버의 자원을 효율적으로 사용할 수 있다.

가령 서버가 하나 있고, A라는 사람이 이 서버에 연결을 해놨고 B라는 사람도 이 서버에다 연결을 해놨다. 이 두 명이 서버에 연결을 물고 있으면, 두 개까지는 문제 없다. 몇 개 더 해도 문제 없다. 그런데 10,000명, 1,000,000명 ... 으로 숫자가 올라간다면 이 서버 하나가 과연 모든 연결을 감당할 수 있을까?

이렇게 연결이 많아지면 부담스러워지니, 서버에서는 한 번 연결을 하고 응답을 줬으면 그 연결을 끊어버린다. 연결을 더 이상 유지하지 않는 것이다.

<br>

### 무 상태 (Stateless)

HTTP의 또 다른 큰 특징은 '<b>무상태 (Stateless)</b>'이다.

<u>서버가 클라이언트의 상태를 저장하지 않는 것이다.</u> 클라이언트의 상태를 알 수 없기 때문에 추가적인 데이터 전송이 필요하고, 응답 서버를 쉽게 바꿀 수 있다. 

그래서 브라우저 쿠키 or 서버 세션 등을 이용하여 상태를 유지한다.

<br>

"클라이언트의 상태를 저장하지 않는다."는 것이 무슨 뜻일까? 예를 들어 내가 edu.ssafy 페이지의 클라이언트이고, edu.ssafy의 서버가 있다고 해보자. 내가 로그인을 이미 마친 상태이다. (로그인 후) 그러면 우측 상단에는 내 사진과 이름, 학번 등이 떠 있다. 내가 로그인을 하려고 했을 때, edu.ssafy 서버에 로그인 요청을 날렸고, 서버에서 DB를 검토하여 "이 사람 있어!"라고 확인하고 로그인을 해주었다.

서버에서는 연결을 끊어버리고 상태를 저장하지 않는다고 했다. 클라이언트 즉 내 브라우저 상태에서는 "로그인 했다"며 우측 상단에 떠 있다. 그런데 서버는 내가 로그인을 했는지 안 했는지 모른다. 만약 연결을 계속 유지하고 있다면 서버 어딘가에 "이 사람 연결 해놨다"라는 것을 알 수 있는데, 모르는 것이다.

내가 어떤 게시글 탭을 눌러서 들어갔을 때, 분명 페이지는 바뀌었는데 우측 상단에 로그인 내역은 유지된다. 분명 서버에서는 연결을 끊어서 상태를 저장하지 않는다고 했는데, 상태가 저장되는 것처럼 보이는 것이다. 무언가 특별한 방법이 필요한 것 같다... 이때 브라우저 쿠키와 세션이 이용되는 것이다.

<br>

"추가적인 데이터 전송이 필요하다는 것"에 대해 비유를 들어서 이해해보자. 내가 손님이고, 모든 것을 처리할 수 있는 로봇 종업원이 있다. 내가 이제 계산을 하려고 한다. 그러면 로봇 종업원 A는 "카드로 할래? 현금으로 할래?" 하고 자리를 떠난다. 그러고 나서 나는 카드든 현금이든 준비를 해서 다시 종업원을 찾는다. 그런데 이번에는 로봇 종업원 B를 찾은 것이다. B 종업원에게 냅다 카드를 주면 B 종업원은 '이 사람 왜 나에게 카드를 주는 거지?' 하고 생각할 것이다. 

왜냐하면 이 로봇 종업원들(서버들)은 실제로 계산할 수 있는 처리 능력이 있지만, 손님에 대한 정보를 저장하고 있지 않기 때문이다.

여기서 "추가적인 데이터 전송이 필요하다"는 것이 연결된다. 로봇 종업원 A에게 "계산을 하려고 한다"라 하면 A는 "카드로 할래? 현금으로 할래?" 하고 사라진다. 그러면 나는 지금 계산을 하려는 행위를 저장하고 있고, 카드로 계산하겠다는 정보를 저장하고 있다. 이러한 두 개의 데이터를 로봇 종업원 B에게 전달하는 것이다. "나 지금 계산하려고 하는데, 카드 여기 있어" 로 하는 것이다. 그러면 종업원 B는 "오케이" 하고 계산을 해주는 것이다.

즉, <u>추가적인 데이터를 보내야 한다는 것은 클라이언트가 "나 지금 뭐 하는 중이었고, 뭐 할래" 라는 것을 계속 보내줘야 한다는 것</u>이다.

위에서 본 edu.ssafy의 예시에서도 학번, 아이디 등을 클라이언트가 저장하고 있다가, 서버에게 "나는 이러이러한 사람이고, 뭘 하고 싶어"라는 요청을 보내는 것이다. 그러면 서버에서는 이 요청 안에 들어있는 정보를 확인해서 "아 너는 이런 사람이구나. 오케이. 이거 할 수 있어"라는 것을 알려준다. <u>이런 정보를 저장하고 있는 것이 쿠키</u>이다.

<br>

## HTTP (HyperText Transfer Protocol) 상태코드

* 1XX : Informational response
* 2XX : Successful response
* 3XX : Redirection messages
* 4XX : Client error responses
* 5XX : Server error responses

웹과 관련된 검색을 할 때 HTTP의 상태(status code)를 볼 수 있는 코드이다. 

Status Code에는 크게 다섯 가지가 있다. 100번대 에러는 거의 쓸 일이 없을 것이다.

200번대 에러는 <b>성공적으로 응답이 왔다는 것</b>이다.

300번대는 <b>리다이렉션 메세지</b>이다. 가령 클라이언트와 서버가 있는 상황에서, 내가 어떤 요청을 처리했는데 서블릿이 동작하면서 response라는 통로에다가 ```response.sendRedirect(경로)```의 방식으로 써놨다. 그러면 이 경로에 "클라이언트에게 새롭게 요청을 보내"라는 경로가 이 경로이다. 이때 요청이 같이 넘어가면서 300번대 메세지가 같이 넘어가는 것이다. 그러면 클라이언트가 이 300번대 메세지를 보고, "아 이거 지금 내가 다시 요청을 보내야겠다" 라는 것을 알게 되고, 바로 넘겨받은 주소로 요청을 다시 보내는 것이다.

400번대 에러는 <b>클라이언트 에러 response</b>이다. 400번대 에러 중 가장 유명한 에러는 404 Error 이다. 사실 클라이언트 입장에서는 403 에러인지, 404 에러인지, 405 에러인지 그닥 중요하지 않다. 그래서 개발자는 404 페이지를 잘 만들어서 클라이언트에게 전부 404 에러 페이지를 보여주는 경향이 있다. 사실 클라이언트의 잘못이지만, 이를 제대로 처리하지 못한 개발자의 잘못으로 보기도 하는 것이다.

500번대 에러는 <b>서버 에러</b>이다. 그런데 500번대 에러가 떴다고 해서 사용자에게 500번대 에러가 떴다고 알려주면 안 된다. 우리는 항상 "네 잘못이야"라고 해야 한다. 404 에러를 띄워야 하는 것이다.
