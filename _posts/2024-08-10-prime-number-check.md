---
layout: post
title: 소수 (Prime Number) 판별 알고리즘
categories: Algorithm
description: 백준 1978번 소수 찾기
date: 2024-08-10 23:51:00 +0900
---
어떤 수가 소수(Prime Number)인지 알아내려면 어떻게 해야 할까?

소수란 "1과 자기 자신만을 약수로 가지는 수"이다.

가령 36 이라는 수를 생각해보자. 36이 소수인지 아닌지 판별하기 위해서는 2 부터 35 까지 순서대로 순회를 돌면서 그 수로 36을 나눈 나머지가 0이 되는지 체크해볼 수 있다.

어떤 N 이라는 수가 주어졌을 때, 그 수가 소수인지 아닌지 판별하려면 2 부터 N - 1 까지 순회를 돌면서 체크를 하면 되는 것이다.

그런데 이렇게 거의 전체 범위를 순회하면서 체크하려면, 시간 복잡도 차원에서 효율적이지 못하다.

<br>

## 해결방안

마찬가지로 36 이라는 숫자를 생각해보자. 36이 소수인지 아닌지 판별하기 위해서 2 부터 35 까지 검토해야 할 필요가 있을까?

36을 2 이상 35 이하의 약수들의 곱으로 표현하면 다음과 같다.

2 × 18, 3 × 12, 4 × 9, 6 × 6, 9 × 4, 12 × 3, 18 × 2

이때 자세히 보면, 2 × 18, 3 × 12, 4 × 9, 6 × 6 까지는 약수끼리의 곱이 이전과 중복되지 않는다. 그런데 9 × 4, 12 × 3, 18 × 2 는 앞의 약수들의 곱과 사실상 같은 것이고 앞 뒤 순서만 바뀐 것을 볼 수 있다.

즉, 36은 2 × 18, 18 × 2 모두 맞지만, 만약 2로 나누어 떨어지는 것만 확인했으면 18로 나누어 떨어지는지를 파악할 필요가 없는 것이다.

<br>

이러한 점을 고려했을 때, <b>어떤 수 N 이 소수인지 판별하려면, 2부터 N의 제곱근 이하의 자연수까지만 검토를 하면 된다</b>는 결론이 나온다.

<a href="https://www.acmicpc.net/problem/1978">백준 1978번 소수 찾기</a>문제의 경우 딱 이상황에 대해 물어보고 있다. 답안 코드는 다음과 같다.

```python
import math     # 제곱근을 사용하기 위해 라이브러리 사용

def isprime(n):
    if n == 1:  # 1은 그냥 배제
        return False
    else:
        for i in range(2, int(math.sqrt(n)) + 1):   # 딱 2부터 제곱근 이하의 자연수까지만 순회를 돌린다.
            if n % i == 0:  # 나누어 떨어진다면 그것은 소수가 아니라는 것
                return False    # 나누어 떨어지는 게 하나라도 나오는 즉시 False를 리턴하고 종료
        return True     # 위의 조건에 하나도 안 걸렸다면 소수라는 것


N = int(input())
nums = list(map(int, input().split()))
cnt = 0

for num in nums:
    if isprime(num):
        cnt += 1

print(cnt)
```

위와 같이 할 경우, 어떤 수가 소수인지 아닌지 판별하기 위해서 순회를 돌아야 하는 양이 획기적으로 줄어든다. 시간 복잡도를 개선할 수 있는 것이다.

위 코드의 경우, N 이 입력 리스트의 크기, m 이 리스트 내의 최대 정수 값이라고 가정한다면 시간 복잡도는 O(N × sqrt(m)) 이라 할 수 있다.

추가적으로, 가지치기(pruning)의 일종으로써 만약 2부터 제곱근 이하의 자연수 중에서 하나라도 나누어 떨어지는 수가 나오면 소수가 아니라는 결론을 내리고, 바로 종료하게 하였다.