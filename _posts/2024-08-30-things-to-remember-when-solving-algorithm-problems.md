---
layout: post
title: 알고리즘 문제 풀 때 유의할 것들 정리
categories: Algorithm
date: 2024-08-30 20:39:00 +0900
---
알고리즘 문제를 풀면서 자주 하는 실수 및 유념해야할 것들을 정리해보겠다.

<br>

## 문제 제대로 읽기

정말 중요한 것이지만, 가끔 문제를 완전히 이해하지 않고 문제풀이를 시작할 때가 있다. 전체적으로 다 이해를 하고, 구상을 시작해야 하는데 읽는 순서대로 구상을 하는 것이다.

이렇게 하면 난이도가 쉬운 문제이거나 내가 운이 좋다면 정답을 한 번에 맞힐 수 있겠지만, 조금만 난이도가 올라가고 복잡해지면 앞서 한 구상을 뒤엎어야 하는 경우가 많이 발생한다. 시간을 낭비하는 것이다.

구상이 잘못된 점을 빨리 찾으면 그나마 다행이지만, 뒤늦게 찾으면 시간이 부족하다는 압박에 여태 구상, 구현한 것을 그대로 가져가고 수정을 하려 할 수 있다. 이렇게 되면 점점 미궁으로 빠지게 된다.

그러므로 <b>문제를 처음부터 끝까지 꼼꼼히 읽고 완전히 이해한 다음 구상, 구현을 시작해야 한다.</b>

<br>

## 테스트케이스 직접 손으로 검증하기

샘플 테스트케이스가 있을 때, 이것을 머릿속으로만 돌려보고 직접 손으로 검증해보지 않는 경우가 있다. 특히 구현(simulation) 문제의 경우 요구사항을 순차적으로 실행해야 하는 경우가 많다. 이때 테스트 케이스를 직접 손으로 A4 용지에 그려가며 단계별로 실행해보면, 내가 이해한 것이 올바른지 아니면 무언가 놓치고 있는 것이 있는지 파악하기 용이하다.

반례를 생각하기 어려운 경우가 있는데, 이 또한 손으로 직접 그려보면서 검증하면 반례를 찾기 쉬워진다. 이전에 풀었던 <a href="https://www.acmicpc.net/problem/3987">백준 3987 보이저 1호</a> 문제의 경우 손으로 직접 그려봤으면 찾을 수 있었을 법한 케이스를 머릿속으로만 판단하여 반례를 오랜 시간 못 찾은 적이 있다.

그러므로 <b>테스트 케이스를 직접 손으로 그려보며 검증해야 한다.</b>

<br>

## 문제 맨 아랫 부분까지 읽기

문제가 있고 테스트케이스가 여러 개 제시되어 있는 상황에서, 간혹 테스트케이스 맨 아랫 부분에 추가적인 설명이 있을 수 있다.

주어진 문제가 있는 페이지의 맨 아랫 부분까지 보지 않으면 테스트케이스들에 대한 면밀한 설명을 보지 못하고 갈 수 있다. <a href="https://www.acmicpc.net/problem/15685">백준 15685 드래곤 커브</a> 문제의 경우가 이러한 예시이다.

혼자서 문제의 지시대로 테스트케이스를 손으로 검증하더라도, 뭔가 이해가 잘 안 될 때가 있다. 이때 문제의 맨 아랫 부분에 있는, 테스트케이스에 대한 구체적인 설명을 보면 상당히 쉽게 이해할 수 있다.

그러므로 <b>문제의 맨 아랫 부분까지 스크롤을 내려보는 습관을 들여야 한다.</b>

<br>

## 메서드는 항상 마지막에 return 문으로 종료한다.

메서드를 사용할 때 편리한 점은 return 문을 사용해 메서드를 완전히 종료할 수 있다는 것이다. 

return문을 잘 사용함으로써 얻을 수 있는 효용은 다음과 같다.

* <b>결과값 전달</b> : return 문이 없으면 메서드는 None 을 반환한다. return 문을 사용하여 값을 반환하면, 이 값을 다른 메서드가 코드 블록에서 사용할 수 있다. 이를 통해 코드를 모듈화하고 재사용할 수 있다.

* <b>메서드 실행 종료</b> : return 문을 만나면 메서드의 실행이 즉시 종료되기 때문에, 특정 상황에서만 실행을 멈추게 하는 것이 가능하다. 또 조건에 따라 메서드를 일찍 종료하여 불필요한 추가 계산을 피할 수 있다.

* <b>코드 가독성 향상</b> : return 문을 적절히 사용하면 메서드가 어떤 결과를 반환하는지 명확해진다. 이는 코드의 가독성을 높인다. 또 메서드의 목적이 명확해진다.

* <b>상태 유지 방지</b> : return문을 사용하여 메서드를 설계하면, 메서드가 외부 상태를 변경하지 않고 입력된 인자만으로 결과를 반환하는 '<u>순수 함수</u>'로 만들 수 있다. 이는 코드의 예측 가능성을 높이고, 디버깅과 테스트를 더 쉽게 만든다.

* <b>재귀 함수에서 중요한 역할</b> : 백트래킹 문제와 같이 재귀 호출을 하는 경우, 종료 조건에서 return문을 사용한다. 그렇지 않으면 무한 루프에 빠지게 된다.

<br>

## 구상 단계에 들어가기 전에 시간 복잡도를 체크한다.

알고리즘 문제 풀이 과정을 크게 4단계로 구분한다면, <b>문제 분석 → 구상 → 구현 → 검증</b> 이라 할 수 있다. 각각의 단계에서 유의해야 할 것들이 있다.

그 중 하나는 문제 분석 단계에서 <u>시간 복잡도를 생각해봐야 한다</u>는 것이다.

어떤 문제를 풀 때에는 다양한 접근 방법이 존재할 수 있다. 어떤 접근 방법을 선택하는지는 다양한 요소가 고려될 수 있다. 어떤 자료구조를 선택하는지, 어떤 알고리즘을 선택하는지, 룩업 테이블(Look-up table)을 전부 입력하는 하드 코딩을 할 것인지, 간결한 코드를 짤 것인지 등.. 다양한 선택지가 있다.

이때 문제에서 주어진 조건을 잘 봐야 한다. 특히 주의 깊게 봐야 하는 것은 시간 제한은 몇 초인지, 메모리 제한은 몇 초인지이다.

만약 시간 제한이 짧게 주어져 있다면 시간 복잡도를 개선할 수 있는 방식으로 접근해야 하는 것이다. 그리고 리스트 등을 불필요하게 많이 생성해서 메모리 차원에서 비효율적으로 관리하고 있는 것은 아닌지도 고려해야 한다.

특히 백트래킹 문제의 경우, 시간 복잡도 체크가 필수이다. 만약 간당간당하다면 가지치기(pruning)를 얼마나 할 수 있을지 고민해봐야 한다.

가령 <a href="https://www.acmicpc.net/problem/15684">백준 15684 사다리 조작</a> 문제의 경우, 시간 복잡도에 대한 큰 고려 없이 코드를 구성했다가 계속 시간 초과로 실패하였다.

효율적인 코드를 짜겠다고 익숙하지 않은 방식으로 짜다가 꼬여서는 안 되겠지만, 시간 복잡도를 고려하지 않고 한참 구상·구현하다가는 나중에 결국 문제가 안 풀렸을 때 시간이 부족해 코드를 뒤엎기 매우 난처할 수 있다.

그러므로 <b>문제풀이 초반에 시간 복잡도에 대한 숙고를 통해 적합한 방법을 선택하는 것이 매우 중요하다.</b>

<br>

## 문제를 이해할 때 자의적인 해석은 절대 하지 않는다.

