---
layout: post
title: 볼링공 고르기
description: 이것이 취업을 위한 코딩 테스트다 with 파이썬 p.315
categories: Algorithm
date: 2023-11-21 23:23:00 +0900
---
볼링공 고르기 문제의 경우, A, B 두 사람이 고를 수 있는 볼링공 조합이라고 하지만, A, B의 순서를 고려하지는 않는 것으로 보인다.

볼링공의 무게가 차례로 1, 3, 2, 3, 2이고, 순서대로 1, 2, 3, 4, 5의 번호를 가지고 있다고 가정해보자.

만약 (A, B)의 방식으로 고려한다면, 위 사례의 경우 두 사람이 고를 수 있는 볼링공 번호의 조합은 다음과 같을 것이다.

(1번, 2번), (1번, 3번), (1번, 4번), (1번, 5번), (2번, 1번), (2번, 3번), (2번, 5번), (3번, 1번), (3번, 2번), (3번, 4번), (4번, 1번), (4번, 3번), (4번, 5번), (5번, 1번), (5번, 2번), (5번, 4번)

즉, 총 16개의 경우가 발생하는 것이다.

하지만, 문제에서는 다음과 같이 8개만 있다고 한다.

(1번, 2번), (1번, 3번), (1번, 4번), (1번, 5번), (2번, 3번), (2번, 5번), (3번, 4번), (4번, 5번)

즉, (A, B)와 같이 A, B의 순서를 고려하지 말고, 그냥 두 명이 나눠가지는 경우의 수만 구하는 것이다.

답안 코드는 다음과 같다.

```python
n, m = map(int, input().split())
balls = list(map(int, input().split()))

count = 0
for i in range(n):
    for j in range(i, n):
        if i == j:
            continue
        if balls[i] != balls[j]:
            count += 1

print(count)
```

<br>

답지에서 제시하는 답안 코드는 다음과 같다.

```python
n, m = map(int, input().split())
data = list(map(int, input().split()))

# 1부터 10까지의 무게를 담을 수 있는 리스트
array = [0] * 11

for x in data:
    # 각 무게에 해당하는 볼링공의 개수 카운트
    array[x] += 1

result = 0
# 1부터 m까지의 각 무게에 대하여 처리
for i in range(1, m + 1):
    n -= array[i]   # 무게가 i인 볼링공의 개수(A가 선택할 수 있는 개수) 제외
    result += array[i] * n  # B가 선택하는 경우의 수와 곱하기

print(result)
```

위 코드의 경우, 내가 제시한 코드보다 시간 복잡도를 획기적으로 줄일 수 있다.

<br>

입력 예시 1

```
5 3
1 3 2 3 2
```

출력 예시 1

```
8
```

입력 예시 2

```
8 5
1 5 4 3 2 4 5 2
```

출력 예시 2

```
25
```