---
layout: post
title: SWEA 16800. 구구단 걷기
categories: Algorithm
date: 2023-11-10 12:04:00 +0900
---
구구단 걷기 문제의 경우 N의 범위가 2 ≤ N ≤ 10¹²이기 때문에, 시간 초과를 피하는 것이 중요하다.

일단, (1, 1)에서 (i, j)까지 이동하기 위해 최소로 움직이는 횟수는 (i - 1) + (j - 1) 번이다.

답안 코드는 다음과 같다.

```python
T = int(input())

for test_case in range(1, T + 1):

    n = int(input())
    current = n - 1
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            current = min(current, (i - 1 + (n // i) - 1))
            
    print(f"#{test_case} {current}")
```

시간 초과를 피하기 위해 반복문을 돌릴 때, 1부터 ```int(n ** 0.5) + 1```까지 돌렸다. n에 0.5를 제곱해주는 것, 즉 √n(루트 n)을 한 것이다. 그러한 이유는 n의 루트값을 내림한 정수값보다 큰 정수값으로 나누면 그 몫은 어차피 1 ~ 루트값을 내림한 정수값 사이에 있기 때문이다. 예를 들어, √50은 7.xx..이고, 이를 내림한 정수값이 7이다. 50을 정수 i × j로 표현하면 (1, 50), (2, 25), (5, 10)의 세 개가 나온다. i는 1부터 7 사이의 값인데, 1, 2, 5까지밖에 안 나오는 것이다. 1 × 50과 50 × 1은 어차피 동일하니 추가로 카운트할 필요 없다.

이렇게 반복문 범위의 값을 루트를 씌워 획기적으로 줄일 수 있는 것이다.

또, 주어진 n의 값이 소수일 수 있으니 일단 처음 값인 current에는 n - 1을 담아둔다. 그리고 반복문을 돌면서 만약 i가 n에 나누어 떨어진다면 current의 값과 새로 구한 값을 비교해 더 작은 것을 current에 담는다.

<br>

예제 입력

```
3
10
50
10000000019
```

예제 출력

```
#1 5
#2 13
#3 10000000018
```