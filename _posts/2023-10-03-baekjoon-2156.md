---
layout: post
title: 백준 2156번 - 포도주 시식
categories: Algorithm
date: 2023-10-03 23:38:00 +0900
---
2156번 포도주 시식 문제는 다이나믹 프로그래밍 문제이다.

두 가지 규칙을 지켜야 한다.

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 선택을 해야 한다.

dp 테이블을 초기화하고, index 0부터 차례대로 최댓값을 구하는 점화식을 찾으면 된다.

6잔의 포도주 [6, 10, 13, 9, 8, 1]가 있는 경우를 생각해보자. 마지막 포도주를 마실지 말지를 결정하는 상황이라고 할 때, 내가 9와 8을 이미 마셨다면 1은 마실 수 없으며, 13과 9를 마신 경우와 13과 8을 마신 경우에는 1을 마실 수 있다.

이 중에서 가장 많이 마실 수 있는 상황을 고르면 되는 것이다.

즉, 현재 포도주를 마실 지 말지를 결정할 때에는
1. <b>현재 포도주와 이전 포도주를 마시고 전전 포도주는 마시지 않는다. (wine[i] + wine[i - 1] + d[i - 3])</b>
2. <b>현재 포도주와 전전 포도주를 마시고 이전 포도주는 마시지 않는다. (wine[i] + d[i - 2])</b>
3. <b>현재 포도주를 마시지 않는다. (d[i - 1])</b>

이렇게 세 가지로 나눌 수 있다. 이때 3번 케이스의 경우 d[i - 2] + wine[i - 1]로 표기하지 않은 이유는 d[i - 1]에 해당 케이스를 포함한 최댓값이 저장되어 있기 때문이다.

포도주 잔이 3잔 이하인 경우에는 인덱스 에러를 방지하기 위해 예외처리를 해주면 된다.

답안 코드는 다음과 같다.

```python
n = int(input())

wine = []
for i in range(n):
    wine.append(int(input()))

d = [0] * n
d[0] = wine[0]

if n > 1:
    d[1] = wine[0] + wine[1]
if n > 2:
    d[2] = max(wine[2] + wine[1], wine[2] + wine[0], d[1])

for i in range(3, n):
    d[i] = max(d[i - 1], wine[i] + d[i - 2], wine[i] + wine[i - 1] + d[i - 3])

print(d[n - 1])
```

예제 입력 1

```
6
6
10
13
9
8
1
```

예제 출력 1

```
33
```

<br>
<br>
<br>
<br>
참고문헌: https://hongcoding.tistory.com/48