---
layout: post
title: 재귀 (Recursion)
categories: Algorithm
date: 2024-08-05 23:03:00 +0900
---
알고리즘 문제풀이 능력을 키우기 위해 재귀(Recursion)는 반드시 넘어야 하는 산이다.

재귀란 되부르는 것으로, 어떤 기능을 하는 함수에 대해 정의를 할 때, 그 "함수의 정의가 자신을 포함하는 형태" 이다.

<br>

재귀를 잘 하려면 큰 문제를 쪼개어서 나눠서 보는 시야를 가져야 한다. 재귀는 반복문과 굉장히 비슷한데, <b>반복적인 것이 보여야 한다.</b> 반복적으로 이뤄지는 것을 포착하고, "이 문제가 재귀를 통해 풀 수 있는 문제인가?" 하는 판단을 해야 한다.

큰 문제를 쪼개고 쪼개고 쪼개어서 바라봐야 한다.

<br>

## 재귀의 3 요건

재귀(Recursion)의 방식으로 코드를 짤 때에는 다음과 같이 3가지 요건을 고려해야 한다.

1. <b>종료 조건</b> (기저 조건)
2. <b>단위 작업 수행</b>
3. <b>재귀 호출</b>

우선 <u>종료 조건은 재귀함수의 제일 위에 있어야 한다.</u> 단위 작업이 위에 있고 종료 조건이 아래에 있으면 무한히 함수가 호출되게 된다. 재귀함수의 제일 윗부분에 명시되어야 하는 것이다.

다음으로 단위 작업은 수행되어야 하는 일의 부분집합이다. 부분이 모여서 전체를 이룰 수 있게끔, 부분을 잘 잡아야 한다.

마지막으로 재귀 호출이란 이미 만들어놓은 라이브러리 함수를 호출하는 것이라고 생각하면 좋다. 무슨 일을 하는지를 고정시켜놓고 호출해야 한다.

<br>

다음 예시를 보자.

1부터 N 까지 출력하는 함수 prt() 가 있다.

```python
def prt(n):
    if n > N:       # [1] 종료 조건
        return
    print(n)        # [2] 단위 작업
    prt(n + 1)      # [3] 재귀 호출
```

<br>

재귀를 짤 때의 TIP은 "지금 이 순간, 이 시점"에서 무엇을 해야 할지를 생각해야 한다는 것이다. 내가 부를 함수를 하나의 완성된 라이브러리라고 생각하고, 그 함수가 할 일을 명확히 정의해야 한다.

또 다른 정말 중요한 TIP은 이다. <b>해당 문제 상황을 Flat 하게 봐야 한다는 것이다.</b> 평평하게 봐야 한다는 것으로, 나머지 작업이 어떻게 수행되어야 할지를 생각하지 말고, 현재 하는 작업에 집중해야 한다.

종료 조건(기저 조건), 단위 작업 등을 설계할 때, 단위 작업을 정하는 '유도 Part'를 먼저 짜고, 그 위에 기저 조건을 붙이고, 마지막에 재귀 호출을 하면 된다. 현재 해야 하는 작업을 빼고, 나머지 작업을 봤을 때 분명히 '같은 일을 하고 있어야' 하는 것이다.

<br>

다음 예시 코드를 보자. 입력된 숫자의 각 자릿수의 숫자들을 더하고, 그것을 출력하는 메서드이다.

```python
def rec(n):
   if n <= 0:   # 몫이 0으로 10보다 작은 수가 남은 상황
       return 0     # 더 이상 값에 더하지 않게
   return rec(n // 10) + n % 10     # 10으로 나눈 나머지를 제외하면, 결국 다시 자기 자신(함수)를 호출할 수 있는 것이다.

N = int(input())
print(rec(N))
```

<br>

또 다른 예시 코드를 보자. 입력된 숫자의 각 자릿수의 숫자들을 곱하는데, 0은 배제하고 곱한 다음 출력하는 메서드이다.

```python
N = int(input())

def mul(n):
   if n <= 0:  # 기저조건 (종료조건)
       return 1
   if n % 10 != 0:
       return mul(n // 10) * (n % 10)
   else:
       return mul(n // 10)

print(mul(N))
```

<br>

재귀 코드를 작성하다 보면 global 키워드 즉, 전역 변수 키워드를 사용하는 경우가 자주 있다. 그런데 실제 프로젝트 등을 수행할 때 전역 변수를 사용하면 부수 효과(side effect)가 발생할 수 있다. 이렇게 전역 변수 키워드를 사용하는 것인 좋은 방법은 아니다.

함수 내에서만 작동을 하는 pure function 을 짜는 것이 바람직하다. 하지만, 문제가 복잡해지는 상황에서 일단 시험 통과가 우선순위이기 때문에 사용해도 된다.

<br>

파이썬은 recursionlimit이 1000 이다. 그래서 depth를 생각해보고 이 문제가 재귀로 풀 수 있는지를 파악할 수 있다. 백준 사이트에서는 recursionlimit을 변경할 수 있지만, 이는 sys 모듈을 사용한 것이고 SWEA 에서는 sys 모듈을 허용하지 않는다. 그러므로 depth가 1000 이내인 경우 재귀를 생각해보고, 그보다 훨씬 크다면 다른 방법을 고민해보는 것이 바람직할 것이다.