---
layout: post
title: 백준 9663번 - N-Queen
categories: Algorithm
date: 2024-08-08 22:11:00 +0900
---
N-Queen 문제는 전형적인 백트래킹(back tracking) 문제이다.

<b>N × N 크기의 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 방법의 수를 구하는 문제</b>이다.

N의 크기는 1 이상 15 미만이다.

예시 입력값은 다음과 같다.

```
8
```

그리고 출력값은 다음과 같다.

```
92
```

<br>

## 문제 분석 및 설계

N × N 크기의 2차원 배열이기 때문에 델타 배열을 이용한 팔방 탐색을 생각할 수 있다. 하지만 재귀 호출이 많이 발생하는 상황에서 무겁게 접근하면 시간 초과가 발생할 확률이 매우 높다.

체스에서 퀸(Queen)은 가로, 세로, 대각선(/), 대각선(\\) 방향으로 이동할 수 있다.

첫 번째 퀸을 체스판에 배치하면, 그 퀸을 기준으로 가로, 세로, 대각선(/), 대각선(\\) 방향의 격자에는 퀸을 배치하면 안 되는 것이다.

그런데 0 행부터 퀸을 배치한다고 생각하면, 체스판의 맨 윗 행에서부터 시작하는 것이니 굳이 팔방 전부를 고려하지 않아도 된다.

0번째 행부터 N - 1 번째 행까지 순서대로 퀸을 배치할 것이기 때문에 가로 방향(동일 행)은 탐색하지 않아도 된다.

결국 탐색해야 하는 것은 세 가지이다.

1. <b>세로 방향 (같은 열인지 탐색)</b>
2. <b>왼쪽 아래 대각선 방향 (/)</b>
3. <b>오른쪽 아래 대각선 방향 (\\)</b>

<br>

이 세 방향을 고려하는 것이, 백트래킹에서 중복 방지를 위해 visited 배열을 사용하는 것으로 구현된다.

세 방향 탐색을 하는 것이기 때문에, <u>세 개의 visited 배열을 만들어야 한다.</u>

다음과 같이 N = 5 인 5 × 5 의 2차원 배열이 있다고 가정해보자.

<img src="https://github.com/user-attachments/assets/f8213a61-aeda-4199-897c-b5874ee884ac" width="300px">

각 칸에는 행, 열 번호가 입력되어 있다.

이때 (0, 2) 칸에 퀸을 놓아보겠다. 그러면 해당 퀸을 기준으로 왼쪽 아래 대각선(/), 아래(같은 열), 오른쪽 아래 방향 대각선(\\) 의 3 방향으로 퀸이 있는지 여부를 검토해야 한다.

<img src="https://github.com/user-attachments/assets/74a5d9e0-d605-4c9d-b98e-c159b1a15c83" width="330px">

<br>

우선 세로(같은 열) 방향의 경우에는 현재 위치시킨 퀸과 같은 열에 있는지 체크하는 것이기 때문에 간단하다.

세로 방향 체크를 위한 visited 배열을 만들 때, 현재 퀸과 열 중복 방지를 위해서 현재 퀸의 인덱스와 동일하게 접근하면 되는 것이다.

<br>

다음으로 왼쪽 아래 대각선(/) 방향 중복 방지 체크이다. 일단 그림을 보자.

<img src="https://github.com/user-attachments/assets/3153880b-40e5-4f59-8f72-abd738e9cc89" width="360px">

위 그림을 보면, 퀸의 좌표가 (0, 2) 일 때, 왼쪽 아래 방향 대각선에 걸치는 좌표들은 (1, 1), (2, 0) 이다. 이때 왼쪽 아래 방향 대각선의 경우 <b>(행의 좌표 + 열의 좌표) 값이 서로 같다</b>는 것을 알 수 있다.

다른 대각선들을 봤을 때에도 가령, 좌표 (1, 3) 의 행과 열을 합한 4는, 좌표 (1, 3) 과 같은 왼쪽 아래 방향 대각선 상에 있는 좌표들인 (0, 4), (2, 2), (3, 1), (4, 0) 모두 행과 열을 합한 값이 4 로, 서로 동일하다.

그림에서 화살표가 시작하는 곳에 써 있는 숫자는 그 대각선 상에 있는 좌표의 행과 열 인덱스를 합한 값이다. visited2 배열이라고 한다면, visited2[행 + 열] 의 값으로 접근할 수 있는 것이다.

그리고 행과 열을 합한 것이다 보니, 행(=열)의 길이인 N 의 두 배 크기 정도의 대각선들로 접근해야 한다. 그래서 길이는 N * 2 로 할 것이다.

<br>

마지막으로 오른쪽 아래 대각선(\\) 방향 중복 방지 체크이다. 일단 그림을 보자.

<img src="https://github.com/user-attachments/assets/02783b3f-2077-4fc9-b2ce-54c63be5f5d9" width="360px">

위 그림을 보면, 퀸의 좌표가 (0, 2) 일 때, 오른쪽 아래 방향 대각선에 걸치는 좌표들은 (1, 3), (2, 4) 이다. 이때 오른쪽 아래 방향 대각선의 경우 <b>(행의 좌표 - 열의 좌표) 값이 서로 같다</b>는 것을 알 수 있다.

다른 대각선들을 봤을 때에도 가령, 좌표 (1, 1) 의 행에서 열을 뺀 0 은, 같은 오른쪽 아래 방향 대각선 상에 있는 좌표들인 (0, 0), (2, 2), (3, 3), (4, 4) 모두 행에서 열을 뺀 값이 0 으로, 서로 동일하다.

그림에서 화살표가 시작하는 곳에 써 있는 숫자는 그 대각선 상에 있는 좌표의 행에서 열을 뺀 값이다. visited3 배열이라고 한다면, visited[행 - 열] 의 값으로 접근할 수 있는 것이다.

그리고 마찬가지로 행에서 열을 뺀 것이다 보니, 범위는 -4 ~ 4 가 되고, N = 5 일 때 거의 두 배에 가까운 크기가 된다. 그래서 길이는 N * 2 로 할 것이다.

<br>

열이 같은지 체크하는 visited1, 왼쪽 아래 방향 대각선이 같은지 체크하는 visited2, 오른쪽 아래 방향 대각선이 같은지 체크하는 visited3 가 있어야 할 때, 편의를 위해 전부 길이를 N * 2 로 하여 초기화 하겠다.

```python
visited1, visited2, visited3 = [[0] * (N * 2) for _ in range(3)]
```

그리고 행을 n, 열을 j 라고 할 때 각각 접근 방법은 다음과 같다.

```python
visited1[j]         # 열 체크
visited2[n + j]     # 왼쪽 아래 방향 대각선 체크
visited3[n - j]     # 오른쪽 아래 방향 대각선 체크
```

이때, n - j 의 경우 음수가 될 수 있는데 파이썬은 인덱스를 음수로 쓸 수 있기 때문에 추가적인 처리를 해주지 않아도 된다. (그냥 이대로 사용하면 된다.)

이제 세 개 배열을 이용해 중복 체크를 하면서 겹치지 않게 퀸을 체스판에 배치하면 된다. 백트래킹 방식으로 접근하면 되겠다.

<br>

## 답안 코드

답안 코드는 다음과 같다.

```python
def nqueen(n):
    global cnt      # 답을 담기 위한 전역 변수 cnt
    if n == N:      # 종료 조건
        cnt += 1
        return

    for j in range(N):
        if visited1[j] == 0 and visited2[n + j] == 0 and visited3[n - j] == 0:  # 8방 탐색을 하며 행~열 순회를 도는 방법보다 훨씬 효율적이다.
            visited1[j], visited2[n + j], visited3[n - j] = 1, 1, 1     # 중복 방지를 위함. 이 중복 방지를 통해 N-Queen 의 조건을 만족할 수 있다.
            nqueen(n + 1)   # nqueen 메서드 재귀 호출
            visited1[j], visited2[n + j], visited3[n - j] = 0, 0, 0


N = int(input())
cnt = 0

visited1, visited2, visited3 = [[0] * (N * 2) for _ in range(3)]    # 방문 체크 배열의 길이를 N * 2 로 한 이유는 대각선이 생성되는 개수에 따른 것이다.

nqueen(0)    # 메서드 실행
print(cnt)
```

추가적인 가지치기(pruning)는 할 것이 없다.