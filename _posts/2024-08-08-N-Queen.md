---
layout: post
title: 백준 9663번 - N-Queen
categories: Algorithm
date: 2024-08-08 22:11:00 +0900
---
N-Queen 문제는 전형적인 백트래킹(back tracking) 문제이다.

<b>N × N 크기의 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 방법의 수를 구하는 문제</b>이다.

N의 크기는 1 이상 15 미만이다.

예시 입력값은 다음과 같다.

```
8
```

그리고 출력값은 다음과 같다.

```
92
```

<br>

## 문제 분석 및 설계

N × N 크기의 2차원 배열이기 때문에 델타 배열을 이용한 팔방 탐색을 생각할 수 있다. 하지만 재귀 호출이 많이 발생하는 상황에서 무겁게 접근하면 시간 초과가 발생할 확률이 매우 높다.

체스에서 퀸(Queen)은 가로, 세로, 대각선(/), 대각선(\\) 방향으로 이동할 수 있다.

첫 번째 퀸을 체스판에 배치하면, 그 퀸을 기준으로 가로, 세로, 대각선(/), 대각선(\\) 방향의 격자에는 퀸을 배치하면 안 되는 것이다.

그런데 0 행부터 퀸을 배치한다고 생각하면, 체스판의 맨 윗 행에서부터 시작하는 것이니 굳이 팔방 전부를 고려하지 않아도 된다.

0번째 행부터 N - 1 번째 행까지 순서대로 퀸을 배치할 것이기 때문에 가로 방향(동일 행)은 탐색하지 않아도 된다.

결국 탐색해야 하는 것은 세 가지이다.

1. <b>세로 방향 (같은 열인지 탐색)</b>
2. <b>왼쪽 아래 대각선 방향 (/)</b>
3. <b>오른쪽 아래 대각선 방향 (\\)</b>

<br>

이 세 방향을 고려하는 것이, 백트래킹에서 중복 방지를 위해 visited 배열을 사용하는 것으로 구현된다.

세 방향 탐색을 하는 것이기 때문에, <u>세 개의 visited 배열을 만들어야 한다.</u>

다음과 같이 N = 5 인 5 × 5 의 2차원 배열이 있다고 가정해보자.

<img src="https://github.com/user-attachments/assets/f8213a61-aeda-4199-897c-b5874ee884ac" width="300px">

각 칸에는 행, 열 번호가 입력되어 있다.

이때 (0, 2) 칸에 퀸을 놓아보겠다. 그러면 해당 퀸을 기준으로 왼쪽 아래 대각선(/), 아래(같은 열), 오른쪽 아래 방향 대각선(\\) 의 3 방향으로 퀸이 있는지 여부를 검토해야 한다.

<img src="https://github.com/user-attachments/assets/74a5d9e0-d605-4c9d-b98e-c159b1a15c83" width="330px">


<br>

## 답안 코드

답안 코드는 다음과 같다.

```python
def nqueen(n):
    global cnt      # 답을 담기 위한 전역 변수 cnt
    if n == N:      # 종료 조건
        cnt += 1
        return

    for j in range(N):
        if visited1[j] == 0 and visited2[n + j] == 0 and visited3[n - j] == 0:  # 8방 탐색을 하며 행~열 순회를 도는 방법보다 훨씬 효율적이다.
            visited1[j], visited2[n + j], visited3[n - j] = 1, 1, 1     # 중복 방지를 위함. 이 중복 방지를 통해 N-Queen 의 조건을 만족할 수 있다.
            nqueen(n + 1)   # nqueen 메서드 재귀 호출
            visited1[j], visited2[n + j], visited3[n - j] = 0, 0, 0


N = int(input())
cnt = 0

visited1, visited2, visited3 = [[0] * (N * 2) for _ in range(3)]    # 방문 체크 배열의 길이를 N * 2 로 한 이유는 대각선이 생성되는 개수에 따른 것이다.

nqueen(0)    # 메서드 실행
print(cnt)
```